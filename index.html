<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Spherical Minesweeper ‚Äì Goldberg Tiling</title>

  <style>

    html, body { height: 100%; margin: 0; background: #4f5059; color: #1a1a1a; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    #app { position: fixed; inset: 0; }

    .ui { position: absolute; top: 12px; left: 12px; padding: 16px 12px 16px 16px; border-radius: 16px; backdrop-filter: blur(20px) saturate(180%); -webkit-backdrop-filter: blur(20px) saturate(180%); background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 100%); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.6), inset 0 -1px 0 rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); width: fit-content; transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .progress-section { display: flex; gap: 16px; align-items: flex-start; margin-bottom: 16px; transition: margin-bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .progress-circle-wrapper { display: flex; flex-direction: column; align-items: center; gap: 6px; position: relative; }

    .progress-circle-wrapper::before { content: ''; position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 80px; height: 80px; border-radius: 50%; background: rgba(0,0,0,0.05); z-index: 0; }

    .progress-circle { width: 80px; height: 80px; border-radius: 50%; position: relative; display: flex; align-items: center; justify-content: center; z-index: 1; }

    .progress-circle .percent { position: relative; z-index: 4; font-size: 16px; font-weight: 700; color: #1a1a1a; text-shadow: 0 0 4px rgba(255,255,255,0.8); transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .progress-circle.mine-hunt { --progress: 0%; position: relative; }

    .progress-circle.mine-hunt::after { content: ''; position: absolute; inset: 0; border-radius: 50%; background: conic-gradient(from 0deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.15) 100%); mask: radial-gradient(circle at center, transparent 20px, black 20px); -webkit-mask: radial-gradient(circle at center, transparent 20px, black 20px); z-index: 0; pointer-events: none; }

    .progress-circle.mine-hunt::before { content: ''; position: absolute; inset: 0; border-radius: 50%; background: conic-gradient(from 0deg, rgba(255,68,68,0.8) 0%, rgba(255,68,68,0.8) var(--progress, 0%), transparent var(--progress, 0%), transparent 100%); mask: radial-gradient(circle at center, black 0px, black 40px); -webkit-mask: radial-gradient(circle at center, black 0px, black 40px); filter: drop-shadow(0 0 10px rgba(255,68,68,1)) drop-shadow(0 0 16px rgba(255,68,68,0.8)); z-index: 1; pointer-events: none; }

    .progress-circle.mine-hunt .progress-dot { position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: #ff4444; border-radius: 50%; box-shadow: 0 0 12px #ff4444, 0 0 20px rgba(255,68,68,0.8); transform-origin: 50% 50%; transform: translate(-50%, -50%) rotate(0deg) translateY(-38px); z-index: 3; pointer-events: none; opacity: 0; transition: opacity 0.2s; }

    .progress-circle.mine-hunt .progress-dot.visible { opacity: 1; }

    .progress-circle.mine-hunt .white-center { position: absolute; inset: 4px; border-radius: 50%; background: rgba(255, 255, 255, 0.95); z-index: 2; pointer-events: none; }

    .progress-circle.mine-hunt .red-dot { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 6px; height: 6px; background: #ff4444; border-radius: 50%; box-shadow: 0 0 8px #ff4444; z-index: 3; pointer-events: none; }

    .progress-circle.exploration { --progress: 0%; position: relative; }

    .progress-circle.exploration::after { content: ''; position: absolute; inset: 0; border-radius: 50%; background: conic-gradient(from 0deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.15) 100%); mask: radial-gradient(circle at center, transparent 20px, black 20px); -webkit-mask: radial-gradient(circle at center, transparent 20px, black 20px); z-index: 0; pointer-events: none; }

    .progress-circle.exploration::before { content: ''; position: absolute; inset: 0; border-radius: 50%; background: conic-gradient(from 0deg, rgba(0,217,255,0.8) 0%, rgba(0,217,255,0.8) var(--progress, 0%), transparent var(--progress, 0%), transparent 100%); mask: radial-gradient(circle at center, black 0px, black 40px); -webkit-mask: radial-gradient(circle at center, black 0px, black 40px); filter: drop-shadow(0 0 10px rgba(0,217,255,1)) drop-shadow(0 0 16px rgba(0,217,255,0.8)); z-index: 1; pointer-events: none; }

    .progress-circle.exploration .progress-dot { position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: #00d9ff; border-radius: 50%; box-shadow: 0 0 12px #00d9ff, 0 0 20px rgba(0,217,255,0.8); transform-origin: 50% 50%; transform: translate(-50%, -50%) rotate(0deg) translateY(-38px); z-index: 3; pointer-events: none; opacity: 0; transition: opacity 0.2s; }

    .progress-circle.exploration .progress-dot.visible { opacity: 1; }

    .progress-circle.exploration .white-center { position: absolute; inset: 4px; border-radius: 50%; background: rgba(255, 255, 255, 0.95); z-index: 2; pointer-events: none; }

    .progress-label { font-size: 12px; color: #1a1a1a; opacity: 0.9; font-weight: 600; transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.3s cubic-bezier(0.4, 0, 0.2, 1), max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1); }

    .progress-value { font-size: 11px; color: #1a1a1a; opacity: 0.8; font-variant-numeric: tabular-nums; transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.3s cubic-bezier(0.4, 0, 0.2, 1), max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1); }

    .hearts-container { display: flex; flex-direction: column; gap: 4px; margin-top: 8px; }

    .heart { width: 20px; height: 20px; color: #ff4444; filter: drop-shadow(0 0 4px rgba(255,68,68,0.6)); font-size: 18px; line-height: 1; transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .timer-section { display: none; align-items: center; gap: 10px; padding: 10px 12px; background: rgba(0,0,0,0.05); border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(0,0,0,0.1); box-sizing: border-box; transition: margin-bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .timer-section.aligned { display: flex; }

    .timer-icon { font-size: 16px; opacity: 0.9; transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .timer-value { font-size: 14px; font-weight: 600; color: #1a1a1a; font-variant-numeric: tabular-nums; letter-spacing: 1px; transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    .ui.compact { padding: 8px 6px 8px 8px; min-width: auto; transform: scale(0.7); transform-origin: top left; }

    .ui.compact .progress-label { opacity: 0; visibility: hidden; max-height: 0; overflow: hidden; }

    .ui.compact .progress-value { opacity: 0; visibility: hidden; max-height: 0; overflow: hidden; }

    .ui.compact .controls-section { opacity: 0; visibility: hidden; max-height: 0; overflow: hidden; pointer-events: none; }

    .ui.compact .progress-section { margin-bottom: 10px; }

    .ui.compact .timer-section { margin-bottom: 10px; }

    .ui.compact .progress-circle .percent { font-size: 24px; }

    .ui.compact .timer-value { font-size: 22px; }

    .ui.compact .timer-icon { font-size: 24px; }

    .ui.compact .heart { font-size: 26px; }

    .controls-section { display: flex; gap: 8px; width: fit-content; box-sizing: border-box; transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.3s cubic-bezier(0.4, 0, 0.2, 1), max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1); }

    .control-btn { width: 40px; height: 40px; border-radius: 10px; background: rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 18px; color: #1a1a1a; }

    .control-btn:hover { background: rgba(0,0,0,0.1); transform: translateY(-1px); }

    .control-btn:active { transform: translateY(0); }

    .control-btn.reset { width: auto; padding: 0 14px; font-size: 12px; font-weight: 600; }

    .row { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px; }

    .row label { font-size: 12px; opacity: 0.9; }

    .row output { font-variant-numeric: tabular-nums; font-size: 12px; opacity: 0.9; }

    input[type=range] { width: 180px; }

    #debugPanel input[type=range] { width: auto; }

    .pill { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); }

    .btn { font-size: 12px; padding: 6px 10px; border-radius: 10px; color: #0b0d12; background: #9ad1ff; border: 0; cursor: pointer; font-weight: 600; }

    .btn:active { transform: translateY(1px); }

    .ok { color: #b1ffb0; }

    .bad { color: #ff8080; }

    #debugPanel { position: fixed; top: 12px; right: 12px; width: 340px; max-height: 90vh; overflow-y: auto; overflow-x: hidden; background: #ffffff; display: none; z-index: 1000; font-family: 'Lucida Grande', sans-serif; font-size: 11px; font-weight: 600; color: #1a1a1a; box-shadow: 0 2px 10px rgba(0,0,0,0.2); border: 1px solid rgba(0,0,0,0.1); box-sizing: border-box; }

    #debugPanel.visible { display: block; }

    .debug-section { border-bottom: 1px solid #e0e0e0; }

    .debug-section-header { display: flex; align-items: center; padding: 4px 8px; cursor: pointer; user-select: none; background: #f5f5f5; color: #1a1a1a; font-weight: 600; margin: 0; }

    .debug-section-header:hover { background: #eeeeee; }

    .debug-section-header .triangle { display: inline-block; width: 0; height: 0; border-left: 4px solid #666; border-top: 3px solid transparent; border-bottom: 3px solid transparent; margin-right: 6px; transition: transform 0.1s; }

    .debug-section-header.collapsed .triangle { transform: rotate(-90deg); }

    .debug-section-content { display: block; }

    .debug-section.collapsed .debug-section-content { display: none; }
    .debug-subsection { padding: 4px 0; border-bottom: 1px solid #f0f0f0; }
    .debug-subsection:last-child { border-bottom: none; }
    .debug-subsection-header { padding: 6px 8px; font-size: 10px; font-weight: 700; color: #666; text-transform: uppercase; letter-spacing: 0.5px; background: #f9f9f9; margin: 0 -8px 4px -8px; }

    .debug-control { display: flex; align-items: center; height: 24px; padding: 0 8px; box-sizing: border-box; min-width: 0; }

    .debug-control:hover { background: #f9f9f9; }

    .debug-control label { flex: 0 0 auto; min-width: 110px; max-width: 110px; font-size: 11px; font-weight: 600; color: #1a1a1a; margin-right: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    .debug-control .control-wrapper { flex: 1; display: flex; align-items: center; height: 20px; position: relative; margin-right: 8px; min-width: 0; }

    .debug-control input[type=range] { flex: 1; height: 20px; min-width: 0; max-width: 100%; width: 100%; -webkit-appearance: none; appearance: none; background: transparent; margin: 0; }

    .debug-control input[type=range]::-webkit-slider-track { height: 2px; background: #ddd; }

    .debug-control input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; background: #0066ff; border: none; border-radius: 0; cursor: pointer; margin-top: -5px; }

    .debug-control input[type=range]::-moz-range-track { height: 2px; background: #ddd; border: none; }

    .debug-control input[type=range]::-moz-range-thumb { width: 12px; height: 12px; background: #0066ff; border: none; border-radius: 0; cursor: pointer; }

    .debug-control input[type=range]::-webkit-slider-runnable-track { height: 2px; background: linear-gradient(to right, #0066ff 0%, #0066ff var(--fill, 0%), #ddd var(--fill, 0%), #ddd 100%); }

    .debug-control input[type=number] { width: 60px; height: 18px; padding: 0 4px; background: #ffffff; border: 1px solid #ddd; color: #0066aa; font-size: 11px; font-family: monospace; text-align: right; }

    .debug-control input[type=number]:focus { outline: 1px solid #0066ff; border-color: #0066ff; }

    .debug-control input[type=color] { width: 40px; height: 18px; border: 1px solid #ddd; cursor: pointer; padding: 0; }

    .debug-control .color-display { width: 40px; height: 18px; border: 1px solid #ddd; margin-right: 8px; cursor: pointer; position: relative; }
    
    .debug-control input[type=color] { 
      position: absolute; 
      top: 0;
      left: 0;
      opacity: 0; 
      width: 40px; 
      height: 18px; 
      cursor: pointer; 
      pointer-events: auto;
      z-index: 10;
      border: none;
      padding: 0;
      margin: 0;
    }

    .debug-control .color-hex { font-size: 10px; color: #0066aa; font-family: monospace; min-width: 50px; }

    .debug-control input[type=checkbox] { width: 14px; height: 14px; margin: 0; cursor: pointer; -webkit-appearance: none; appearance: none; background: #ffffff; border: 1px solid #999; position: relative; }

    .debug-control input[type=checkbox]:checked { background: #0066ff; border-color: #0066ff; }

    .debug-control input[type=checkbox]:checked::after { content: '‚úì'; position: absolute; top: -2px; left: 2px; color: #fff; font-size: 12px; }

    .debug-control button { padding: 4px 12px; background: #f5f5f5; border: 1px solid #ddd; color: #1a1a1a; cursor: pointer; font-size: 11px; font-family: inherit; }

    #debugSaveClipboard { padding: 8px 12px; background: #0066ff; border: 1px solid #0055dd; color: #ffffff; cursor: pointer; font-size: 11px; font-family: inherit; font-weight: 600; border-radius: 4px; transition: background 0.2s; }

    #debugSaveClipboard:hover { background: #0055dd; }

    #debugLoadClipboard { padding: 8px 12px; background: #28a745; border: 1px solid #218838; color: #ffffff; cursor: pointer; font-size: 11px; font-family: inherit; font-weight: 600; border-radius: 4px; transition: background 0.2s; }

    #debugLoadClipboard:hover { background: #218838; }

    .debug-control button:hover { background: #eeeeee; }

    .debug-control select { flex: 1; height: 18px; background: #ffffff; border: 1px solid #ddd; color: #1a1a1a; font-size: 11px; padding: 0 4px; margin-right: 8px; }

    #debugCloseBtn { width: 100%; padding: 8px; background: #f5f5f5; border: none; border-top: 1px solid #e0e0e0; color: #1a1a1a; cursor: pointer; font-size: 11px; font-family: inherit; }

    #debugCloseBtn:hover { background: #eeeeee; }

    /* Loading and Game Over Overlays */
    .game-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      background: rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .game-overlay.visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .game-overlay-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-radius: 20px;
      padding: 40px 60px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08), inset 0 1px 0 rgba(255, 255, 255, 0.6), inset 0 -1px 0 rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.5);
      text-align: center;
      max-width: 400px;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .game-overlay.visible .game-overlay-content {
      transform: scale(1);
    }

    .game-overlay-title {
      font-size: 48px;
      font-weight: 700;
      color: #dc3545;
      margin-bottom: 12px;
      text-shadow: none;
      letter-spacing: -0.5px;
    }

    .game-overlay-title.win {
      color: #28a745;
    }

    .game-overlay-title.loss {
      color: #dc3545;
    }

    .game-overlay-subtitle {
      font-size: 20px;
      color: #666;
      margin-bottom: 32px;
      line-height: 1.4;
      font-weight: 400;
    }

    .game-overlay-message {
      font-size: 18px;
      color: #666;
      margin-bottom: 24px;
      line-height: 1.5;
      font-weight: 400;
    }

    .game-overlay-stats {
      font-size: 16px;
      margin-bottom: 32px;
      line-height: 2;
      text-align: left;
      display: inline-block;
      min-width: 280px;
    }

    .game-overlay-stats .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .game-overlay-stats .stat-row:last-child {
      border-bottom: none;
    }

    .game-overlay-stats .stat-label {
      color: #999;
      font-weight: 400;
    }

    .game-overlay-stats .stat-value {
      font-weight: 600;
      color: #333;
      font-variant-numeric: tabular-nums;
    }

    .game-overlay-button {
      padding: 12px 32px;
      background: linear-gradient(135deg, rgba(0, 102, 255, 0.8) 0%, rgba(0, 85, 221, 0.8) 100%);
      backdrop-filter: blur(10px) saturate(180%);
      -webkit-backdrop-filter: blur(10px) saturate(180%);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 102, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      transition: all 0.2s;
      font-family: inherit;
    }

    .game-overlay-button:hover {
      background: linear-gradient(135deg, rgba(0, 85, 221, 0.9) 0%, rgba(0, 68, 204, 0.9) 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 102, 255, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    .game-overlay-button:active {
      transform: translateY(0);
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 102, 255, 0.2);
      border-top-color: #0066ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
      filter: drop-shadow(0 0 8px rgba(0, 102, 255, 0.5));
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

  </style>

</head>

<body>

  <div id="app"></div>

  <!-- Loading Game Overlay -->
  <div id="loadingOverlay" class="game-overlay">
    <div class="game-overlay-content">
      <div class="loading-spinner"></div>
      <div class="game-overlay-title">Loading Game...</div>
      <div class="game-overlay-message" id="loadingMessage">Generating solvable puzzle...</div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="game-overlay">
    <div class="game-overlay-content">
      <div class="game-overlay-title" id="gameOverTitle">Game Over</div>
      <div class="game-overlay-subtitle" id="gameOverSubtitle">You ran out of lives</div>
      <div class="game-overlay-stats">
        <div class="stat-row">
          <span class="stat-label">Mine Hunt:</span>
          <span class="stat-value" id="statMineHunt">0%</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Exploration:</span>
          <span class="stat-value" id="statExploration">0%</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Flags:</span>
          <span class="stat-value" id="statFlags">0/0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Revealed:</span>
          <span class="stat-value" id="statRevealed">0/0</span>
        </div>
      </div>
      <button class="game-overlay-button" id="restartButton">Restart</button>
    </div>
  </div>

  <div class="ui">

    <div class="progress-section">

      <div class="progress-circle-wrapper">

        <div class="progress-circle mine-hunt" id="mineHuntCircle">

          <div class="white-center"></div>

          <div class="red-dot"></div>

          <div class="progress-dot"></div>

          <div class="percent" id="mineHuntPercent">0%</div>

        </div>

        <div class="progress-label" style="font-weight: 600;">Mine Hunt</div>

        <div class="progress-value" id="mineHuntValue">0/0</div>

      </div>

      <div class="progress-circle-wrapper">

        <div class="progress-circle exploration" id="explorationCircle">

          <div class="white-center"></div>

          <div class="progress-dot"></div>

          <div class="percent" id="explorationPercent">0%</div>

        </div>

        <div class="progress-label" style="font-weight: 600;">Exploration</div>

        <div class="progress-value" id="explorationValue">0/0</div>

      </div>

      <div class="hearts-container" id="heartsContainer">

        <div class="heart">‚ô•</div>

        <div class="heart">‚ô•</div>

        <div class="heart">‚ô•</div>

      </div>

    </div>

    <div class="timer-section">

      <span class="timer-icon">üïê</span>

      <span class="timer-value" id="timerValue">00:00</span>

    </div>

    <div class="controls-section">

      <button class="control-btn reset" id="newGame">Reset</button>

      <button class="control-btn" id="soundToggle" title="Toggle Sound">üîä</button>

      <button class="control-btn" id="debugToggle" title="Toggle Debug Panel (Ctrl+Shift+Alt+D)">‚öôÔ∏è</button>

      <button class="control-btn" id="globeBtn" title="Globe">üåê</button>

    </div>

  </div>



  <div id="debugPanel">

    <div class="debug-section">

      <div class="debug-section-header"><span class="triangle"></span>Game Settings</div>

      <div class="debug-section-content">

        <div class="debug-control"><label>Tile Density</label><div class="control-wrapper"><input type="range" id="debugFreq" min="1" max="20" step="1" value="15" /></div><input type="number" id="debugFreqValue" value="15" readonly /></div>

        <div class="debug-control"><label>Mine %</label><div class="control-wrapper"><input type="range" id="debugMineRatio" min="5" max="30" step="1" value="7" /></div><input type="number" id="debugMineRatioValue" value="7" readonly /></div>

        <div class="debug-control"><label>Empty Tile %</label><div class="control-wrapper"><input type="range" id="debugEmptyRatio" min="0" max="100" step="1" value="30" /></div><input type="number" id="debugEmptyRatioValue" value="30" readonly /></div>

        <div class="debug-control"><label>Initial Reveal %</label><div class="control-wrapper"><input type="range" id="debugInitialReveal" min="0" max="100" step="1" value="12" /></div><input type="number" id="debugInitialRevealValue" value="12" readonly /></div>

        <div class="debug-control"><label>Glass</label><div class="control-wrapper"><input type="range" id="debugGlass" min="0" max="1" step="0.01" value="0" /></div><input type="number" id="debugGlassValue" value="0" step="0.01" readonly /></div>

        <div class="debug-control"><label>Glass Tint</label><div class="color-display" id="debugGlassTintDisplay" style="background: #5a7aff; position: relative;"><input type="color" id="debugGlassTint" value="#5a7aff" /></div><span class="color-hex" id="debugGlassTintHex">#5a7aff</span></div>

        <div class="debug-control"><label>Immortal Mode</label><div class="control-wrapper"></div><input type="checkbox" id="debugImmortal" /></div>

      </div>

    </div>

    <div class="debug-section collapsed">

      <div class="debug-section-header collapsed"><span class="triangle"></span>Wireframe Colors</div>

      <div class="debug-section-content">

        <div class="debug-control"><label>Hex Color</label><div class="color-display" id="debugWireHexDisplay" style="background: #1e2129; position: relative;"><input type="color" id="debugWireHex" value="#1e2129" /></div><span class="color-hex" id="debugWireHexHex">#1e2129</span></div>

        <div class="debug-control"><label>Pent Color</label><div class="color-display" id="debugWirePentDisplay" style="background: #1e2129; position: relative;"><input type="color" id="debugWirePent" value="#1e2129" /></div><span class="color-hex" id="debugWirePentHex">#1e2129</span></div>

      </div>

    </div>

    <div class="debug-section collapsed">

      <div class="debug-section-header collapsed"><span class="triangle"></span>Tile Colors</div>

      <div class="debug-section-content">

        <div class="debug-control"><label>Hidden</label><div class="color-display" id="debugTileHiddenDisplay" style="background: #313f5e; position: relative;"><input type="color" id="debugTileHidden" value="#313f5e" /></div><span class="color-hex" id="debugTileHiddenHex">#313f5e</span></div>

        <div class="debug-control"><label>Revealed</label><div class="color-display" id="debugTileRevealedDisplay" style="background: #4c5b7b; position: relative;"><input type="color" id="debugTileRevealed" value="#4c5b7b" /></div><span class="color-hex" id="debugTileRevealedHex">#4c5b7b</span></div>

        <div class="debug-control"><label>Flag</label><div class="color-display" id="debugTileFlagDisplay" style="background: #ff6b6b; position: relative;"><input type="color" id="debugTileFlag" value="#ff6b6b" /></div><span class="color-hex" id="debugTileFlagHex">#ff6b6b</span></div>

        <div class="debug-control"><label>Mine</label><div class="color-display" id="debugTileMineDisplay" style="background: #ff4444; position: relative;"><input type="color" id="debugTileMine" value="#ff4444" /></div><span class="color-hex" id="debugTileMineHex">#ff4444</span></div>

      </div>

    </div>

    <div class="debug-section">

      <div class="debug-section-header"><span class="triangle"></span>Number Labels</div>

      <div class="debug-section-content">

        <div class="debug-control"><label>Offset</label><div class="control-wrapper"><input type="range" id="debugLabelOffset" min="1" max="1.1" step="0.001" value="1.015" /></div><input type="number" id="debugLabelOffsetValue" value="1.015" step="0.001" readonly /></div>

        <div class="debug-control"><label>Rotation (deg)</label><div class="control-wrapper"><input type="range" id="debugLabelRot" min="0" max="360" step="1" value="0" /></div><input type="number" id="debugLabelRotValue" value="0" readonly /></div>

        <div class="debug-control"><label>Rot X (deg)</label><div class="control-wrapper"><input type="range" id="debugLabelRotX" min="0" max="360" step="1" value="0" /></div><input type="number" id="debugLabelRotXValue" value="0" readonly /></div>

        <div class="debug-control"><label>Rot Y (deg)</label><div class="control-wrapper"><input type="range" id="debugLabelRotY" min="0" max="360" step="1" value="0" /></div><input type="number" id="debugLabelRotYValue" value="0" readonly /></div>

        <div class="debug-control"><label>Rot Z (deg)</label><div class="control-wrapper"><input type="range" id="debugLabelRotZ" min="0" max="360" step="1" value="0" /></div><input type="number" id="debugLabelRotZValue" value="0" readonly /></div>

        <div class="debug-control"><label>Scale</label><div class="control-wrapper"><input type="range" id="debugLabelScale" min="0.01" max="0.2" step="0.01" value="0.07" /></div><input type="number" id="debugLabelScaleValue" value="0.07" step="0.01" readonly /></div>

        <div class="debug-control"><label>Color</label><div class="color-display" id="debugLabelColorDisplay" style="background: #aeb5c4; position: relative;"><input type="color" id="debugLabelColor" value="#aeb5c4" /></div><span class="color-hex" id="debugLabelColorHex">#aeb5c4</span></div>

      </div>

    </div>

    <div class="debug-section">

      <div class="debug-section-header collapsed"><span class="triangle"></span>Lighting</div>

      <div class="debug-section-content">

        <div class="debug-subsection">
          <div class="debug-subsection-header">Hemisphere Light</div>
        <div class="debug-control"><label>Sky Color</label><div class="color-display" id="debugHemiSkyDisplay" style="background: #ffffff; position: relative;"><input type="color" id="debugHemiSky" value="#ffffff" /></div><span class="color-hex" id="debugHemiSkyHex">#ffffff</span></div>

        <div class="debug-control"><label>Ground Color</label><div class="color-display" id="debugHemiGroundDisplay" style="background: #cccccc; position: relative;"><input type="color" id="debugHemiGround" value="#cccccc" /></div><span class="color-hex" id="debugHemiGroundHex">#cccccc</span></div>

        <div class="debug-control"><label>Intensity</label><div class="control-wrapper"><input type="range" id="debugHemiIntensity" min="0" max="2" step="0.1" value="0.5" /></div><input type="number" id="debugHemiIntensityValue" value="0.5" step="0.1" readonly /></div>

        </div>
        <div class="debug-subsection">
          <div class="debug-subsection-header">Directional Light</div>
        <div class="debug-control"><label>Color</label><div class="color-display" id="debugDirColorDisplay" style="background: #ffffff; position: relative;"><input type="color" id="debugDirColor" value="#ffffff" /></div><span class="color-hex" id="debugDirColorHex">#ffffff</span></div>

        <div class="debug-control"><label>Intensity</label><div class="control-wrapper"><input type="range" id="debugDirIntensity" min="0" max="2" step="0.1" value="0.7" /></div><input type="number" id="debugDirIntensityValue" value="0.7" step="0.1" readonly /></div>

        <div class="debug-control"><label>Position X</label><div class="control-wrapper"><input type="range" id="debugDirX" min="-10" max="10" step="0.1" value="2.8" /></div><input type="number" id="debugDirXValue" value="2.8" step="0.1" readonly /></div>

        <div class="debug-control"><label>Position Y</label><div class="control-wrapper"><input type="range" id="debugDirY" min="-10" max="10" step="0.1" value="1.8" /></div><input type="number" id="debugDirYValue" value="1.8" step="0.1" readonly /></div>

        <div class="debug-control"><label>Position Z</label><div class="control-wrapper"><input type="range" id="debugDirZ" min="-10" max="10" step="0.1" value="-1.2" /></div><input type="number" id="debugDirZValue" value="-1.2" step="0.1" readonly /></div>

        <div class="debug-control"><label>Distance</label><div class="control-wrapper"><input type="range" id="debugDirDistance" min="1" max="100" step="1" value="20" /></div><input type="number" id="debugDirDistanceValue" value="20" step="1" readonly /></div>

        <div class="debug-control"><label>Decay</label><div class="control-wrapper"><input type="range" id="debugDirDecay" min="0" max="3" step="0.1" value="2" /></div><input type="number" id="debugDirDecayValue" value="2" step="0.1" readonly /></div>

        <div class="debug-control"><label>Shadow Map Size</label><div class="control-wrapper"><input type="range" id="debugDirShadowMapSize" min="256" max="4096" step="256" value="2048" /></div><input type="number" id="debugDirShadowMapSizeValue" value="2048" readonly /></div>

        <div class="debug-control"><label>Shadow Radius</label><div class="control-wrapper"><input type="range" id="debugDirShadowRadius" min="0" max="20" step="0.5" value="4" /></div><input type="number" id="debugDirShadowRadiusValue" value="4" step="0.5" readonly /></div>

        </div>
        <div class="debug-subsection">
          <div class="debug-subsection-header">Point Light</div>
        <div class="debug-control"><label>Color</label><div class="color-display" id="debugCenterLightColorDisplay" style="background: #ffffff; position: relative;"><input type="color" id="debugCenterLightColor" value="#ffffff" /></div><span class="color-hex" id="debugCenterLightColorHex">#ffffff</span></div>

        <div class="debug-control"><label>Intensity</label><div class="control-wrapper"><input type="range" id="debugCenterLightIntensity" min="0" max="3" step="0.1" value="1.0" /></div><input type="number" id="debugCenterLightIntensityValue" value="1.0" step="0.1" readonly /></div>

        <div class="debug-control"><label>Distance</label><div class="control-wrapper"><input type="range" id="debugCenterLightDistance" min="1" max="20" step="0.5" value="5" /></div><input type="number" id="debugCenterLightDistanceValue" value="5" step="0.5" readonly /></div>

        <div class="debug-control"><label>Decay</label><div class="control-wrapper"><input type="range" id="debugCenterLightDecay" min="0" max="3" step="0.1" value="2" /></div><input type="number" id="debugCenterLightDecayValue" value="2" step="0.1" readonly /></div>
        </div>

      </div>

    </div>

    <div class="debug-section collapsed">
      <div class="debug-section-header collapsed"><span class="triangle"></span>Sound</div>
      <div class="debug-section-content">
        <div class="debug-control"><label>Click Sound</label><div class="control-wrapper"><input type="range" id="debugClickSound" min="1" max="5" step="1" value="5" /></div><input type="number" id="debugClickSoundValue" value="5" readonly /></div>
        <div class="debug-control"><label>Game Over Sound</label><div class="control-wrapper"><input type="range" id="debugGameOverSound" min="1" max="5" step="1" value="1" /></div><input type="number" id="debugGameOverSoundValue" value="1" readonly /></div>
      </div>
    </div>

    <div class="debug-section">

      <div class="debug-section-header"><span class="triangle"></span>Camera</div>

      <div class="debug-section-content">

        <div class="debug-control"><label>Background</label><div class="color-display" id="debugCamBgDisplay" style="background: #4f5059; position: relative;"><input type="color" id="debugCamBg" value="#4f5059" /></div><span class="color-hex" id="debugCamBgHex">#4f5059</span></div>

        <div class="debug-control"><label>FOV</label><div class="control-wrapper"><input type="range" id="debugCamFOV" min="10" max="120" step="1" value="32" /></div><input type="number" id="debugCamFOVValue" value="32" readonly /></div>

        <div class="debug-control"><label>Position X</label><div class="control-wrapper"><input type="range" id="debugCamX" min="-10" max="10" step="0.1" value="3.1" /></div><input type="number" id="debugCamXValue" value="3.1" step="0.1" readonly /></div>

        <div class="debug-control"><label>Position Y</label><div class="control-wrapper"><input type="range" id="debugCamY" min="-10" max="10" step="0.1" value="0.6" /></div><input type="number" id="debugCamYValue" value="0.6" step="0.1" readonly /></div>

        <div class="debug-control"><label>Position Z</label><div class="control-wrapper"><input type="range" id="debugCamZ" min="-10" max="10" step="0.1" value="1.4" /></div><input type="number" id="debugCamZValue" value="1.4" step="0.1" readonly /></div>

        <div class="debug-control"><label>Near</label><div class="control-wrapper"><input type="range" id="debugCamNear" min="0.01" max="1" step="0.001" value="0.01" /></div><input type="number" id="debugCamNearValue" value="0.01" step="0.001" readonly /></div>

        <div class="debug-control"><label>Far</label><div class="control-wrapper"><input type="range" id="debugCamFar" min="10" max="1000" step="1" value="100" /></div><input type="number" id="debugCamFarValue" value="100" readonly /></div>

        <div class="debug-control"><label>Fog Enabled</label><div class="control-wrapper"></div><input type="checkbox" id="debugCamFog" /></div>

      </div>

    </div>

    <button id="debugSaveClipboard" style="width: 100%; margin-bottom: 8px;">üìã Save to Clipboard</button>

    <button id="debugLoadClipboard" style="width: 100%; margin-bottom: 8px;">üì• Load from Clipboard</button>

    <button id="debugCloseBtn">Close Controls</button>

  </div>

  <div id="fpsCounter" style="position: fixed; bottom: 12px; right: 12px; font-family: monospace; font-size: 12px; color: #1a1a1a; background: rgba(255, 255, 255, 0.8); padding: 4px 8px; border-radius: 4px; backdrop-filter: blur(8px); z-index: 100;">FPS: --</div>

  <!-- Three.js (UMD) pinned to r146 so OrbitControls works without modules -->

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Post-processing for blur effect -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/shaders/CopyShader.js"></script>



  <script>

    // ===== Geometry core =====

    function icosahedron(radius = 1) {

      const t = (1 + Math.sqrt(5)) / 2;

      const verts = [

        new THREE.Vector3(-1,  t,  0), new THREE.Vector3( 1,  t,  0), new THREE.Vector3(-1, -t,  0), new THREE.Vector3( 1, -t,  0),

        new THREE.Vector3( 0, -1,  t), new THREE.Vector3( 0,  1,  t), new THREE.Vector3( 0, -1, -t), new THREE.Vector3( 0,  1, -t),

        new THREE.Vector3( t,  0, -1), new THREE.Vector3( t,  0,  1), new THREE.Vector3(-t,  0, -1), new THREE.Vector3(-t,  0,  1),

      ];

      for (const v of verts) v.normalize().multiplyScalar(radius);

      const faces = [

        [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],

        [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],

        [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],

        [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]

      ];

      return { verts, faces };

    }



    function geodesicSubdivide(base, frequency, radius) {

      const vertMap = new Map();

      const getVertId = (v) => {

        const s = 1e6;

        const key = `${Math.round(v.x * s)}_${Math.round(v.y * s)}_${Math.round(v.z * s)}`;

        if (!vertMap.has(key)) {

          const id = vertMap.size;

          const normalized = v.clone().normalize().multiplyScalar(radius);

          vertMap.set(key, { id, v: normalized });

        }

        return vertMap.get(key).id;

      };



      const newVerts = [];

      const newFaces = [];



      for (const face of base.faces) {

        const v0 = base.verts[face[0]];

        const v1 = base.verts[face[1]];

        const v2 = base.verts[face[2]];



        const subdivs = [];

        for (let i = 0; i <= frequency; i++) {

          const row = [];

          for (let j = 0; j <= i; j++) {

            const a = (frequency - i) / frequency;

            const b = (i - j) / frequency;

            const c = j / frequency;

            const v = new THREE.Vector3()

              .addScaledVector(v0, a)

              .addScaledVector(v1, b)

              .addScaledVector(v2, c);

            row.push(v);

          }

          subdivs.push(row);

        }



        for (let i = 0; i < frequency; i++) {

          for (let j = 0; j <= i; j++) {

            const a = subdivs[i][j];

            const b = subdivs[i + 1][j];

            const c = subdivs[i + 1][j + 1];

            newFaces.push([getVertId(a), getVertId(b), getVertId(c)]);

            if (j < i) {

              const d = subdivs[i][j + 1];

              newFaces.push([getVertId(a), getVertId(c), getVertId(d)]);

            }

          }

        }

      }



      const vertArray = Array.from({ length: vertMap.size });

      for (const entry of vertMap.values()) {

        vertArray[entry.id] = entry.v;

      }



      return { verts: vertArray, faces: newFaces };

    }



    function buildDualPolygons(verts, faces) {

      const incident = Array.from({length: verts.length}, () => []);

      const faceCentroids = faces.map(f => {

        const c = new THREE.Vector3();

        c.add(verts[f[0]]).add(verts[f[1]]).add(verts[f[2]]).multiplyScalar(1/3).normalize();

        return c;

      });

      faces.forEach((f, fi) => { f.forEach(v => incident[v].push(fi)); });



      const polys = [];

      const tmpU = new THREE.Vector3();

      const tmpV = new THREE.Vector3();

      for (let vi=0; vi<verts.length; vi++) {

        const v = verts[vi].clone().normalize();

        const ref = Math.abs(v.x) < 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);

        const u = tmpU.copy(ref).cross(v).normalize();

        const w = tmpV.copy(v).cross(u).normalize();

        const list = incident[vi].map(fi => {

          const c = faceCentroids[fi];

          const ang = Math.atan2(c.dot(w), c.dot(u));

          return { fi, ang, c };

        }).sort((a,b)=>a.ang-b.ang);

        polys.push(list.map(o => o.c.clone()));

      }

      return polys; // Array<Array<Vector3>>

    }



    function buildAdjacency(polys) {

      const vertId = new Map();

      const idOf = (v)=>{

        const s=1e5; const key = `${Math.round(v.x*s)}_${Math.round(v.y*s)}_${Math.round(v.z*s)}`;

        let id = vertId.get(key); if (id===undefined){ id = vertId.size; vertId.set(key,id);} return id;

      };

      const edgeMap = new Map();

      const neigh = polys.map(()=> new Set());

      polys.forEach((poly, pi)=>{

        const ids = poly.map(idOf);

        const n = ids.length;

        for (let i=0;i<n;i++){

          const a = ids[i], b = ids[(i+1)%n];

          const k = a<b ? `${a}_${b}` : `${b}_${a}`;

          const prev = edgeMap.get(k);

          if (prev===undefined) edgeMap.set(k, pi); else { neigh[pi].add(prev); neigh[prev].add(pi); }

        }

      });

      return neigh.map(set=>Array.from(set));

    }



    function polygonToMesh(poly, mat) {

      const center = new THREE.Vector3(); poly.forEach(p=>center.add(p)); center.multiplyScalar(1/poly.length).normalize();

      const n = poly.length;

      const positions = [];

      for (let i=0;i<n;i++){

        const a = poly[i];

        const b = poly[(i+1)%n];

        positions.push(center.x,center.y,center.z, a.x,a.y,a.z, b.x,b.y,b.z);

      }

      const g = new THREE.BufferGeometry();

      g.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(positions),3));

      // Compute normals for lighting - required for MeshStandardMaterial
      // For flat faces, we need to compute face normals first, then vertex normals
      g.computeVertexNormals();
      
      // Ensure normals point outward from sphere center (each face is a triangle from center)
      // Since we're using DoubleSide, normals should work in both directions, but let's ensure they point out
      const normals = g.attributes.normal;
      if (normals) {
        const positions = g.attributes.position;
        for (let i = 0; i < normals.count; i++) {
          const nx = positions.getX(i);
          const ny = positions.getY(i);
          const nz = positions.getZ(i);
          // Normalize the position vector to get outward normal
          const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
          if (len > 0) {
            normals.setXYZ(i, nx / len, ny / len, nz / len);
          }
        }
        normals.needsUpdate = true;
      }

      return new THREE.Mesh(g, mat);

    }



    function makeNumberSprite(n, scale, colorOverride = null) {

      const size = 128; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;

      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0,0,size,size);

      ctx.font = '700 72px system-ui, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

      // All numbers use the same color (from debug panel or default)
      // If no color provided, calculate lighter version of revealed tile color
      let finalColor = colorOverride;
      if (!finalColor) {
        const revealedColor = document.getElementById('debugTileRevealed')?.value || '#4c5b7b';
        finalColor = lightenColor(revealedColor, 0.55);
      }
      ctx.fillStyle = finalColor;

      ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 8;

      ctx.fillText(String(n), size/2, size/2);

      const tex = new THREE.CanvasTexture(canvas); tex.anisotropy = 4; tex.needsUpdate = true;

      const m = new THREE.SpriteMaterial({ map: tex, transparent: true });

      const s = new THREE.Sprite(m);

      const k = scale != null ? scale : 0.12; s.scale.set(k,k,k);

      return s;

    }



    // ===== Utilities =====

    function labelScale(f){

      const k = 0.34 / Math.max(1, f);

      return Math.max(0.06, Math.min(0.16, k));

    }

    // Lighten a hex color by a factor (0-1, where 1 = white)
    function lightenColor(hex, factor = 0.55) {
      // Remove # if present
      hex = hex.replace('#', '');
      
      // Parse RGB
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      
      // Lighten each component
      const lightR = Math.round(r + (255 - r) * factor);
      const lightG = Math.round(g + (255 - g) * factor);
      const lightB = Math.round(b + (255 - b) * factor);
      
      // Convert back to hex
      return '#' + [lightR, lightG, lightB].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }



    function buildEdgeLines(polys, colorHex, colorPent, neighbors, tiles) {

      const pts = [], pentPts = [];
      
      // Build a map of edges to tiles for quick lookup
      // An edge is defined by two vertices (as a sorted pair)
      const edgeToTiles = new Map();
      
      // For each tile, record which edges it has
      polys.forEach((poly, tileIndex) => {
        const n = poly.length;
        for (let i = 0; i < n; i++) {
          const a = poly[i];
          const b = poly[(i + 1) % n];
          // Create a unique key for the edge (sorted vertices)
          const edgeKey = a.x < b.x || (a.x === b.x && a.y < b.y) || (a.x === b.x && a.y === b.y && a.z < b.z)
            ? `${a.x},${a.y},${a.z}_${b.x},${b.y},${b.z}`
            : `${b.x},${b.y},${b.z}_${a.x},${a.y},${a.z}`;
          
          if (!edgeToTiles.has(edgeKey)) {
            edgeToTiles.set(edgeKey, []);
          }
          edgeToTiles.get(edgeKey).push(tileIndex);
        }
      });

      // Build edge lines, skipping edges between two empty tiles
      for (let tileIndex = 0; tileIndex < polys.length; tileIndex++) {
        const poly = polys[tileIndex];
        const n = poly.length;
        const tileIsEmpty = tiles && tiles[tileIndex] && tiles[tileIndex].isEmpty;

        for (let i = 0; i < n; i++) {
          const a = poly[i];
          const b = poly[(i + 1) % n];
          
          // Create edge key
          const edgeKey = a.x < b.x || (a.x === b.x && a.y < b.y) || (a.x === b.x && a.y === b.y && a.z < b.z)
            ? `${a.x},${a.y},${a.z}_${b.x},${b.y},${b.z}`
            : `${b.x},${b.y},${b.z}_${a.x},${a.y},${a.z}`;
          
          // Get all tiles sharing this edge
          const tilesOnEdge = edgeToTiles.get(edgeKey) || [];
          
          // Check if all tiles on this edge are empty
          const allEmpty = tilesOnEdge.every(tIdx => tiles && tiles[tIdx] && tiles[tIdx].isEmpty);
          
          // Only draw edge if not all adjacent tiles are empty
          if (!allEmpty) {
            pts.push(a.x, a.y, a.z, b.x, b.y, b.z);
            
            if (n === 5) {
              pentPts.push(a.x, a.y, a.z, b.x, b.y, b.z);
            }
          }
        }
      }

      const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pts), 3));

      const lines = new THREE.LineSegments(g, new THREE.LineBasicMaterial({ color: colorHex }));

      let pentLines = null; if (pentPts.length) { const gp = new THREE.BufferGeometry(); gp.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pentPts), 3)); pentLines = new THREE.LineSegments(gp, new THREE.LineBasicMaterial({ color: colorPent })); }

      return { lines, pentLines };

    }



    // ===== Scene setup =====

    const app = document.getElementById('app');

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x4f5059);

    const camera = new THREE.PerspectiveCamera(32, innerWidth/innerHeight, 0.01, 100); camera.position.set(3.1, 0.6, 1.4);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
    renderer.setSize(innerWidth, innerHeight); 
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5)); // Reduced from 2 for better performance 
    renderer.sortObjects = false; // Disable sorting for better performance - only enable when needed for transparency
    renderer.setClearColor(0x4f5059, 1); // Set clear color to match background
    app.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement); 
    controls.enableDamping = true;
    controls.dampingFactor = 0.05; // Smooth damping for camera movement
    controls.enableRotate = false; // Disable camera rotation - we'll rotate the sphere instead
    controls.enableZoom = true; // Enable zoom
    controls.zoomSpeed = 0.5; // Smooth, slower zoom speed
    controls.enablePan = false; // Disable panning
    controls.smoothZoom = true; // Enable smooth zoom interpolation



    const hemi = new THREE.HemisphereLight(0xffffff, 0xcccccc, 0.5); scene.add(hemi);

    const dir = new THREE.PointLight(0xffffff, 0.7); dir.position.set(2.8, 1.8, -1.2); scene.add(dir); // PointLight with distance falloff
    
    // Configure distance-based intensity falloff
    dir.distance = 20; // Distance at which intensity becomes 0
    dir.decay = 2; // Decay rate (1 = linear, 2 = physically correct)
    
    // Center point light for illuminating internal faces of tiles
    const centerLight = new THREE.PointLight(0xffffff, 1.0);
    centerLight.position.set(0, 0, 0); // Center of the sphere
    centerLight.distance = 5; // Distance at which intensity becomes 0
    centerLight.decay = 2; // Decay rate
    scene.add(centerLight);
    
    // Shadows disabled by default (very expensive - 2048x2048 shadow maps for many tiles)
    // Enable shadows only if needed (uncomment below)
    // dir.castShadow = true;
    // dir.shadow.mapSize.width = 1024; // Reduced from 2048 for better performance
    // dir.shadow.mapSize.height = 1024;
    // dir.shadow.camera.near = 0.5;
    // dir.shadow.camera.far = 50;
    // dir.shadow.radius = 4;
    // renderer.shadowMap.enabled = true;
    // renderer.shadowMap.type = THREE.PCFSoftShadowMap;



    let wireGroup = new THREE.Group(); scene.add(wireGroup);

    let tileGroup = new THREE.Group(); scene.add(tileGroup);

    let wireHexMaterial = null; let wirePentMaterial = null;



    // ===== Minesweeper state & materials =====
    // Using MeshLambertMaterial for better performance (per-vertex vs per-pixel lighting)
    const matHidden = new THREE.MeshLambertMaterial({ color: 0x313f5e, side: THREE.DoubleSide });

    const matRevealed = new THREE.MeshLambertMaterial({ color: 0x4c5b7b, side: THREE.DoubleSide });

    const matFlag = new THREE.MeshLambertMaterial({ color: 0xff6b6b, side: THREE.DoubleSide }); // bright red

    const matMine = new THREE.MeshLambertMaterial({ color: 0xff4444, side: THREE.DoubleSide });

    // Simple glass material for empty tiles - no complex shaders for better performance
    const matEmpty = new THREE.MeshLambertMaterial({
      color: 0x4c5b7b,
      transparent: true,
      opacity: 0.4,
      depthWrite: false,
      depthTest: true,
      side: THREE.DoubleSide
    });



    const state = { f: 15, polys: [], neighbors: [], tiles: [], firstClick: true, gameOver: false, safeRevealed: 0, totalMines: 0, flags: 0, lives: 3, won: false };

    let revealQueue = [];
    let revealQueueSet = new Set(); // Track queued tiles for O(1) lookup instead of O(n) includes()
    let isRevealing = false;
    let isInitialReveal = false;
    let lifeLostInCurrentReveal = false;
    let rightClickHandled = false;
    let contextMenuHandled = false;
    let touchFlagHandled = false;



    function rebuildWireframe() {
      // Rebuild wireframe, skipping edges between empty tiles
      scene.remove(wireGroup);
      wireGroup.clear();
      wireGroup = new THREE.Group();
      scene.add(wireGroup);
      
      const hexColor = wireHexMaterial ? wireHexMaterial.color.getHex() : 0x1e2129;
      const pentColor = wirePentMaterial ? wirePentMaterial.color.getHex() : 0x1e2129;
      
      const { lines, pentLines } = buildEdgeLines(state.polys, hexColor, pentColor, state.neighbors, state.tiles);
      
      wireHexMaterial = lines.material;
      if (pentLines) wirePentMaterial = pentLines.material;
      
      wireGroup.add(lines);
      if (pentLines) wireGroup.add(pentLines);
    }

    function buildTiles() {

      scene.remove(wireGroup); wireGroup.clear(); wireGroup = new THREE.Group(); scene.add(wireGroup);

      scene.remove(tileGroup); tileGroup.clear(); tileGroup = new THREE.Group(); scene.add(tileGroup);

      const hexColor = wireHexMaterial ? wireHexMaterial.color.getHex() : 0x1e2129;

      const pentColor = wirePentMaterial ? wirePentMaterial.color.getHex() : 0x1e2129;

      // Initial wireframe build (tiles not yet created, so all edges shown)
      const { lines, pentLines } = buildEdgeLines(state.polys, hexColor, pentColor, state.neighbors, null);

      wireHexMaterial = lines.material;

      if (pentLines) wirePentMaterial = pentLines.material;

      wireGroup.add(lines); if (pentLines) wireGroup.add(pentLines);

      state.tiles = state.polys.map((poly, i)=>{

        const mesh = polygonToMesh(poly, matHidden); // Share material instead of cloning

        const center = new THREE.Vector3(); poly.forEach(p=>center.add(p)); center.multiplyScalar(1/poly.length).normalize();

        // Set renderOrder so empty tiles render first (behind other tiles)
        // This ensures edges of other tiles are visible through empty tiles
        mesh.renderOrder = 0; // Default render order
        
        tileGroup.add(mesh);

        return { index:i, mesh, center, mine:false, count:0, flagged:false, revealed:false, label:null, isEmpty:false };

      });

    }



    const debugSettings = { initialRevealPercent: 12, emptyTilePercent: 30, mineRatio: 7, labelScale: 0.07 };

    function findSafeTile(){
      const revealed = new Set(state.tiles.map((t, i) => t.revealed ? i : -1).filter(i => i >= 0));
      const flagged = new Set(state.tiles.map((t, i) => t.flagged ? i : -1).filter(i => i >= 0));
      
      let foundNewSafe = true;
      let iterations = 0;
      const maxIterations = 200;
      
      while (foundNewSafe && iterations < maxIterations) {
        iterations++;
        foundNewSafe = false;
        
        // Cascade reveal all tiles with count 0
        let cascadeFound = true;
        while (cascadeFound) {
          cascadeFound = false;
          for (const tileIdx of revealed) {
            const t = state.tiles[tileIdx];
            if (t.count === 0) {
              const neighbors = state.neighbors[tileIdx];
              for (const nb of neighbors) {
                if (!revealed.has(nb) && !flagged.has(nb) && !state.tiles[nb].isEmpty && !state.tiles[nb].mine) {
                  revealed.add(nb);
                  cascadeFound = true;
                  foundNewSafe = true;
                }
              }
            }
          }
        }
        
        // Check each revealed tile for deductions
        for (const tileIdx of revealed) {
          const t = state.tiles[tileIdx];
          if (t.count === 0) continue;
          
          const neighbors = state.neighbors[tileIdx];
          const hiddenNeighbors = neighbors.filter(nb => !revealed.has(nb) && !flagged.has(nb) && !state.tiles[nb].isEmpty);
          const flaggedNeighbors = neighbors.filter(nb => flagged.has(nb));
          
          const remainingMines = t.count - flaggedNeighbors.length;
          
          // If all mines are flagged, remaining neighbors must be safe
          if (remainingMines === 0 && hiddenNeighbors.length > 0) {
            for (const nb of hiddenNeighbors) {
              if (!state.tiles[nb].mine) {
                return nb;
              }
            }
          }
        }
      }
      
      return null;
    }

    function checkIfStuckAndHelp(){
      if (state.gameOver || state.won) return;
      
      const safeTile = findSafeTile();
      
      if (safeTile !== null && !state.tiles[safeTile].revealed) {
        reveal(safeTile);
        return true;
      }
      
      return false;
    }

    function isBoardSolvable(){
      const revealed = new Set(state.tiles.map((t, i) => t.revealed ? i : -1).filter(i => i >= 0));
      const flagged = new Set(state.tiles.map((t, i) => t.flagged ? i : -1).filter(i => i >= 0));
      const totalSafe = state.tiles.filter(t => !t.mine && !t.isEmpty).length;
      
      let foundNewSafe = true;
      let iterations = 0;
      const maxIterations = 1000;
      
      while (foundNewSafe && revealed.size < totalSafe && iterations < maxIterations) {
        iterations++;
        foundNewSafe = false;
        
        // Cascade reveal all tiles with count 0
        let cascadeFound = true;
        let cascadeIterations = 0;
        while (cascadeFound && cascadeIterations < 100) {
          cascadeIterations++;
          cascadeFound = false;
          for (const tileIdx of revealed) {
            const t = state.tiles[tileIdx];
            if (t.count === 0) {
              const neighbors = state.neighbors[tileIdx];
              for (const nb of neighbors) {
                if (!revealed.has(nb) && !flagged.has(nb) && !state.tiles[nb].isEmpty && !state.tiles[nb].mine) {
                  revealed.add(nb);
                  cascadeFound = true;
                  foundNewSafe = true;
                }
              }
            }
          }
        }
        
        // Check each revealed tile for basic deductions
        for (const tileIdx of revealed) {
          const t = state.tiles[tileIdx];
          if (t.count === 0) continue;
          
          const neighbors = state.neighbors[tileIdx];
          const hiddenNeighbors = neighbors.filter(nb => !revealed.has(nb) && !flagged.has(nb) && !state.tiles[nb].isEmpty);
          const flaggedNeighbors = neighbors.filter(nb => flagged.has(nb));
          
          const remainingMines = t.count - flaggedNeighbors.length;
          const remainingHidden = hiddenNeighbors.length;
          
          // If all mines are flagged, remaining neighbors must be safe
          if (remainingMines === 0 && remainingHidden > 0) {
            foundNewSafe = true;
            for (const nb of hiddenNeighbors) {
              if (!state.tiles[nb].mine) {
                revealed.add(nb);
              }
            }
          }
          
          // If remaining hidden neighbors == remaining mines needed, all must be mines
          if (remainingMines === remainingHidden && remainingHidden > 0) {
            for (const nb of hiddenNeighbors) {
              if (state.tiles[nb].mine && !flagged.has(nb)) {
                flagged.add(nb);
                foundNewSafe = true;
              }
            }
          }
        }
      }
      
      return revealed.size === totalSafe;
    }

    function placeMines(excludeIndex, ratioPercent, initialRevealPercent = 0, emptyTilePercent = 0){
      const total = state.tiles.length; const mineTarget = Math.max(1, Math.floor(total * ratioPercent/100));

      // Show loading overlay
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.classList.add('visible');
      }

      // Use setTimeout to allow UI to update
      setTimeout(() => {
        // Try to generate a solvable board (max 10 attempts for better solvability)
        let attempts = 0;
        const maxAttempts = 10;
        let boardIsSolvable = false;

        const tryGenerateBoard = () => {
          if (boardIsSolvable || attempts >= maxAttempts) {
            continueBoardSetup(initialRevealPercent);
            return;
          }

          attempts++;

          // Update loading message with attempt info
          const loadingMessage = document.getElementById('loadingMessage');
          if (loadingMessage) {
            loadingMessage.textContent = attempts === 1 ? 'Generating solvable puzzle...' : `Attempt ${attempts} of ${maxAttempts}...`;
          }

          setTimeout(() => {
            state.totalMines = mineTarget; state.flags = 0; state.safeRevealed = 0; state.gameOver=false; state.won = false; state.lives = 3; lifeLostInCurrentReveal = false; updateCounters();

            state.tiles.forEach(t=>{ t.mine=false; t.count=0; t.flagged=false; t.revealed=false; t.isEmpty=false; if (t.label){ tileGroup.remove(t.label); t.label.material.map.dispose(); t.label.material.dispose(); t.label=null; } t.mesh.material = t.isEmpty ? matEmpty : matHidden; });

            const forbidden = excludeIndex >= 0 ? new Set([excludeIndex, ...state.neighbors[excludeIndex]]) : new Set();

            let placed = 0; const indices = [...state.tiles.keys()].filter(i=>!forbidden.has(i) && !state.tiles[i].isEmpty);

            // Handle empty tiles
            if (emptyTilePercent > 0) {
              const emptyCount = Math.floor(indices.length * emptyTilePercent / 100);
              for (let i = indices.length - 1; i > 0 && emptyCount > 0; i--) {
                const j = (Math.random() * (i + 1)) | 0;
                [indices[i], indices[j]] = [indices[j], indices[i]];
              }
              for (let i = 0; i < emptyCount; i++) {
                const idx = indices[i];
                state.tiles[idx].count = 0;
                state.tiles[idx].isEmpty = true;
                state.tiles[idx].mesh.material = matEmpty; // Share material for empty tiles
              }
              indices.splice(0, emptyCount);
              
              // Rebuild wireframe to hide edges between empty tiles
              rebuildWireframe();
            }

            // Simple random mine placement
            for (let i=indices.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [indices[i],indices[j]]=[indices[j],indices[i]]; }

            for (let i = 0; i < mineTarget && i < indices.length; i++) {
              state.tiles[indices[i]].mine = true;
              placed++;
            }

            state.tiles.forEach((t,i)=>{ if (t.mine) return; let c=0; for (const nb of state.neighbors[i]) if (state.tiles[nb].mine) c++; t.count=c; });

            // Reveal initial percentage of safe tiles at the start
            const safeIndices = state.tiles.map((t, i) => i).filter(i => !state.tiles[i].mine && !state.tiles[i].isEmpty);
            const revealCount = Math.max(1, Math.floor(safeIndices.length * initialRevealPercent / 100));

            // Shuffle safe indices
            for (let i = safeIndices.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [safeIndices[i], safeIndices[j]] = [safeIndices[j], safeIndices[i]];
            }

            // Reveal initial tiles for solvability check
            const initialRevealed = new Set();
            for (let i = 0; i < revealCount && i < safeIndices.length; i++) {
              initialRevealed.add(safeIndices[i]);
            }

            setTimeout(() => {
              // Check if board is solvable from this initial state
              const originalRevealed = state.tiles.map(t => t.revealed);
              initialRevealed.forEach(idx => { state.tiles[idx].revealed = true; });
              
              boardIsSolvable = isBoardSolvable();
              
              // Restore original revealed state
              state.tiles.forEach((t, i) => { t.revealed = originalRevealed[i]; });
              
              if (!boardIsSolvable && attempts < maxAttempts) {
                // Use requestAnimationFrame for next attempt to avoid blocking
                requestAnimationFrame(() => {
                  tryGenerateBoard();
                });
              } else {
                continueBoardSetup(initialRevealPercent);
              }
            });
          });
        };

        tryGenerateBoard();
      }, 0);
    }

    function continueBoardSetup(initialRevealPercent) {
      // Hide loading overlay
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.classList.remove('visible');
      }

      // Add initial tiles to reveal queue for one-by-one processing
      const safeIndices = state.tiles.map((t, i) => i).filter(i => !state.tiles[i].mine && !state.tiles[i].isEmpty);
      const revealCount = Math.max(1, Math.floor(safeIndices.length * initialRevealPercent / 100));
      
      // Shuffle safe indices for random initial reveal
      for (let i = safeIndices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [safeIndices[i], safeIndices[j]] = [safeIndices[j], safeIndices[i]];
      }

      // Add to reveal queue
      revealQueue = [];
      revealQueueSet.clear();
      for (let i = 0; i < revealCount && i < safeIndices.length; i++) {
        revealQueue.push(safeIndices[i]);
        revealQueueSet.add(safeIndices[i]);
      }

      // Start revealing tiles one by one
      isInitialReveal = true;
      processRevealQueue();
      
      // Start timer when game begins
      startTimer();
    }



    function revealSingle(i){
      const t = state.tiles[i]; 
      
      if (rightClickHandled || contextMenuHandled) {
        return false;
      }
      
      if (t.revealed || t.flagged || state.gameOver || t.isEmpty) return false;

      t.revealed = true;
      
      // Apply appropriate material: mine, empty (glass), or revealed
      if (t.mine) {
        t.mesh.material = matMine;
      } else if (t.isEmpty) {
        t.mesh.material = matEmpty;
      } else {
        t.mesh.material = matRevealed;
      }

      if (t.mine){ 
        if (!document.getElementById('debugImmortal')?.checked) {
          gameLost(i); 
          if (state.lives > 0) {
            return true;
          }
          return false; 
        }
        return false;
      }

      state.safeRevealed++;

      if (t.count>0 && !t.isEmpty){ addLabel(i, t.count); }

      if (!isInitialReveal) {
        playSound('reveal');
      }

      checkWin(); updateCounters();
      
      // If this tile has count 0, add adjacent safe tiles to reveal queue
      if (t.count === 0) {
        for (const nb of state.neighbors[i]) {
          const neighbor = state.tiles[nb];
          if (!neighbor.revealed && !neighbor.flagged && !neighbor.isEmpty && !neighbor.mine) {
            if (!revealQueue.includes(nb)) {
              revealQueue.push(nb);
            }
          }
        }
      }

      return true;
    }

    function processRevealQueue(){
      if (revealQueue.length === 0 || isRevealing) return;

      isRevealing = true;
      let soundPlayed = false; // Only play sound once per cascade
      
      // Initial reveal: process all tiles synchronously at once
      if (isInitialReveal) {
        while (revealQueue.length > 0 && !state.gameOver) {
          const idx = revealQueue.shift();
          if (idx === undefined) break;
          
          revealQueueSet.delete(idx);
          
          const t = state.tiles[idx];
          if (!t.revealed && !t.flagged && !t.isEmpty) {
            t.revealed = true;
            
            if (t.mine) {
              t.mesh.material = matMine;
              if (!document.getElementById('debugImmortal')?.checked) {
                isRevealing = false;
                isInitialReveal = false;
                revealQueue.length = 0;
                revealQueueSet.clear();
                gameLost(idx);
                return;
              }
            } else {
              t.mesh.material = matRevealed;
              state.safeRevealed++;
            }
            
            if (t.count > 0) {
              addLabel(idx, t.count);
            }
            
            if (t.count === 0) {
              for (const nb of state.neighbors[idx]) {
                const neighbor = state.tiles[nb];
                if (!neighbor.revealed && !neighbor.flagged && !neighbor.isEmpty && !neighbor.mine) {
                  if (!revealQueueSet.has(nb)) {
                    revealQueue.push(nb);
                    revealQueueSet.add(nb);
                  }
                }
              }
            }
          }
        }
        
        // Batch expensive operations at the end
        updateCounters();
        checkWin();
        
        isRevealing = false;
        isInitialReveal = false;
        revealQueueSet.clear();
        
        if (!lifeLostInCurrentReveal) {
          checkIfStuckAndHelp();
        }
        return;
      }
      
      // Normal cascade: process tiles one by one with 10ms delay between each
      function revealNext(){
        if (revealQueue.length === 0 || state.gameOver){
          // Batch expensive operations at the end
          updateCounters();
          checkWin();
          
          isRevealing = false;
          revealQueueSet.clear();
          
          // Don't auto-reveal if a mine was just hit
          if (!lifeLostInCurrentReveal) {
            checkIfStuckAndHelp();
          }
          return;
        }

        // Process ONE tile
        const idx = revealQueue.shift();
        if (idx === undefined) {
          setTimeout(revealNext, 10);
          return;
        }
        
        // Remove from set
        revealQueueSet.delete(idx);
        
        const t = state.tiles[idx];
        if (!t.revealed && !t.flagged && !t.isEmpty) {
          // Reveal this tile
          t.revealed = true;
          
          // Update material
          if (t.mine) {
            t.mesh.material = matMine;
            if (!document.getElementById('debugImmortal')?.checked) {
              isRevealing = false;
              revealQueue.length = 0;
              revealQueueSet.clear();
              gameLost(idx);
              return;
            }
          } else {
            t.mesh.material = matRevealed;
            state.safeRevealed++; // Only count non-empty, non-mine tiles
          }
          
          // Add label if needed (only for numbered tiles)
          if (t.count > 0) {
            addLabel(idx, t.count);
          }
          
          // Play sound only once per cascade (not per tile)
          if (!soundPlayed) {
            playSound('reveal');
            soundPlayed = true;
          }
          
          // If this tile has count 0, add adjacent safe tiles to reveal queue
          if (t.count === 0) {
            for (const nb of state.neighbors[idx]) {
              const neighbor = state.tiles[nb];
              if (!neighbor.revealed && !neighbor.flagged && !neighbor.isEmpty && !neighbor.mine) {
                if (!revealQueueSet.has(nb)) {
                  revealQueue.push(nb);
                  revealQueueSet.add(nb);
                }
              }
            }
          }
        }
        
        // Process next tile after 10ms delay
        setTimeout(revealNext, 10);
      }

      revealNext();
    }

    function reveal(i){
      if (state.gameOver) return;
      
      if (rightClickHandled || contextMenuHandled || touchFlagHandled) {
        return;
      }

      const t = state.tiles[i]; if (t.revealed || t.flagged) return;

      if (!isRevealing && revealQueue.length === 0){
        lifeLostInCurrentReveal = false;
        revealQueue.push(i);
        revealQueueSet.add(i);
        processRevealQueue();
      } else {
        if (!revealQueueSet.has(i)) {
          revealQueue.push(i);
          revealQueueSet.add(i);
        }
      }
    }



    function addLabel(i, n){

      const t = state.tiles[i]; if (t.label) return;

      // Get label color, or calculate it from revealed tile color if not set
      let labelColorHex = document.getElementById('debugLabelColor')?.value;
      if (!labelColorHex) {
        const revealedColor = document.getElementById('debugTileRevealed')?.value || '#4c5b7b';
        labelColorHex = lightenColor(revealedColor, 0.55);
      }

      const s = makeNumberSprite(n, labelScale(state.f), labelColorHex); s.position.copy(t.center).multiplyScalar(1.015);

      tileGroup.add(s); t.label = s;

    }



    function toggleFlag(i){ 
      const t = state.tiles[i]; 
      if (t.revealed || state.gameOver) return; 
      t.flagged = !t.flagged; 
      t.mesh.material = t.flagged ? matFlag : matHidden; 
      state.flags += t.flagged ? 1 : -1; 
      updateCounters();
      // Play sound for flag toggle
      if (t.flagged) {
        playSound('flag');
      } else {
        playSound('unflag');
      }
    }



    function chord(i){ const t = state.tiles[i]; if (!t.revealed || state.gameOver) return; const flagsAround = state.neighbors[i].reduce((acc,nb)=> acc + (state.tiles[nb].flagged?1:0),0); if (flagsAround === t.count){ for (const nb of state.neighbors[i]) if (!state.tiles[nb].flagged && !state.tiles[nb].revealed) reveal(nb); } }



    function gameLost(mineIndex){
      if (document.getElementById('debugImmortal')?.checked) return;
      
      // Only lose one life per reveal sequence (click)
      if (lifeLostInCurrentReveal) return;
      
      lifeLostInCurrentReveal = true;
      state.lives--;
      
      // Play mine explosion sound (only once)
      playSound('mine');
      
      // Update hearts display
      const hearts = document.querySelectorAll('.heart');
      if (hearts.length > 0 && state.lives >= 0 && state.lives < hearts.length) {
        hearts[state.lives].style.opacity = '0.3';
      }
      
      if (state.lives <= 0) {
        state.gameOver = true;
        stopTimer();
        state.tiles.forEach((t)=>{ if (t.mine){ t.mesh.material = matMine; if (!t.revealed) { t.revealed = true; } } });
        
        // Show game over overlay with stats
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverSubtitle = document.getElementById('gameOverSubtitle');
        const statMineHunt = document.getElementById('statMineHunt');
        const statExploration = document.getElementById('statExploration');
        const statFlags = document.getElementById('statFlags');
        const statRevealed = document.getElementById('statRevealed');
        
        if (gameOverOverlay) {
          if (gameOverTitle) {
            gameOverTitle.textContent = 'Game Over';
            gameOverTitle.className = 'game-overlay-title loss';
          }
          if (gameOverSubtitle) {
            gameOverSubtitle.textContent = 'You ran out of lives';
          }
          
          // Calculate stats
          const emptyTileCount = state.tiles.filter(t => t.isEmpty).length;
          const totalSafe = state.tiles.length - state.totalMines - emptyTileCount;
          const nonEmptySafeRevealed = state.tiles.filter(t => t.revealed && !t.mine && !t.isEmpty).length;
          const minePercent = state.totalMines > 0 ? Math.round((state.flags / state.totalMines) * 100) : 0;
          const explorePercent = totalSafe > 0 ? Math.round((nonEmptySafeRevealed / totalSafe) * 100) : 0;
          
          if (statMineHunt) statMineHunt.textContent = `${minePercent}%`;
          if (statExploration) statExploration.textContent = `${explorePercent}%`;
          if (statFlags) statFlags.textContent = `${state.flags}/${state.totalMines}`;
          if (statRevealed) statRevealed.textContent = `${nonEmptySafeRevealed}/${totalSafe}`;
          
          gameOverOverlay.classList.add('visible');
        }
      }
      // Removed duplicate playSound('lifeLost') call - mine sound already played
    }



    function checkWin(){ 
      const totalSafe = state.tiles.filter(t => !t.mine && !t.isEmpty).length;
      if (state.safeRevealed >= totalSafe){ 
        state.gameOver = true; 
        state.won = true; 
        stopTimer();
        
        // Show game over overlay with win stats
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverSubtitle = document.getElementById('gameOverSubtitle');
        const statMineHunt = document.getElementById('statMineHunt');
        const statExploration = document.getElementById('statExploration');
        const statFlags = document.getElementById('statFlags');
        const statRevealed = document.getElementById('statRevealed');
        
        if (gameOverOverlay) {
          if (gameOverTitle) {
            gameOverTitle.textContent = 'Victory!';
            gameOverTitle.className = 'game-overlay-title win';
          }
          if (gameOverSubtitle) {
            gameOverSubtitle.textContent = 'You cleared all safe tiles!';
          }
          
          // Calculate stats
          const emptyTileCount = state.tiles.filter(t => t.isEmpty).length;
          const totalSafe = state.tiles.length - state.totalMines - emptyTileCount;
          const nonEmptySafeRevealed = state.tiles.filter(t => t.revealed && !t.mine && !t.isEmpty).length;
          const minePercent = state.totalMines > 0 ? Math.round((state.flags / state.totalMines) * 100) : 0;
          const explorePercent = 100;
          
          if (statMineHunt) statMineHunt.textContent = `${minePercent}%`;
          if (statExploration) statExploration.textContent = `${explorePercent}%`;
          if (statFlags) statFlags.textContent = `${state.flags}/${state.totalMines}`;
          if (statRevealed) statRevealed.textContent = `${nonEmptySafeRevealed}/${totalSafe}`;
          
          gameOverOverlay.classList.add('visible');
        }
        
        // Play win sound
        playVictory();
      } 
    }



    function updateCounters(){

      const mineHuntPercent = state.totalMines > 0 ? Math.round((state.flags / state.totalMines) * 100) : 0;

      const mineHuntCircle = document.getElementById('mineHuntCircle');

      mineHuntCircle.style.setProperty('--progress', `${mineHuntPercent}%`);

      const mineHuntDot = mineHuntCircle.querySelector('.progress-dot');

      if (mineHuntDot) {

        mineHuntDot.style.transform = `translate(-50%, -50%) rotate(${mineHuntPercent * 3.6}deg) translateY(-38px)`;

        if (mineHuntPercent > 0) {

          mineHuntDot.classList.add('visible');

        } else {

          mineHuntDot.classList.remove('visible');

        }

      }

      document.getElementById('mineHuntPercent').textContent = `${mineHuntPercent}%`;

      document.getElementById('mineHuntValue').textContent = `${state.flags}/${state.totalMines}`;

      // Calculate total safe tiles excluding empty tiles (empty tiles are not part of the game)
      const emptyTileCount = state.tiles.filter(t => t.isEmpty).length;
      const totalSafe = state.tiles.length - state.totalMines - emptyTileCount;
      
      // Count only non-empty safe tiles revealed (empty tiles don't count toward exploration)
      const nonEmptySafeRevealed = state.tiles.filter(t => t.revealed && !t.mine && !t.isEmpty).length;
      
      const explorationPercent = totalSafe > 0 ? Math.round((nonEmptySafeRevealed / totalSafe) * 100) : 0;

      const explorationCircle = document.getElementById('explorationCircle');

      explorationCircle.style.setProperty('--progress', `${explorationPercent}%`);

      const explorationDot = explorationCircle.querySelector('.progress-dot');

      if (explorationDot) {

        explorationDot.style.transform = `translate(-50%, -50%) rotate(${explorationPercent * 3.6}deg) translateY(-38px)`;

        if (explorationPercent > 0) {

          explorationDot.classList.add('visible');

        } else {

          explorationDot.classList.remove('visible');

        }

      }

      document.getElementById('explorationPercent').textContent = `${explorationPercent}%`;

      document.getElementById('explorationValue').textContent = `${nonEmptySafeRevealed}/${totalSafe}`;

    }



    let gameStartTime = null; let timerInterval = null;

    let compactTimeout = null;

    function scheduleCompactMode(){

      const ui = document.querySelector('.ui');

      if (compactTimeout) clearTimeout(compactTimeout);

      if (ui) ui.classList.remove('compact');

      compactTimeout = setTimeout(() => { if (ui) ui.classList.add('compact'); }, 5000);

    }

    function startTimer(){

      if (timerInterval) clearInterval(timerInterval);

      gameStartTime = Date.now();

      scheduleCompactMode();

      timerInterval = setInterval(() => {

        if (!gameStartTime || state.gameOver) return;

        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);

        const mins = Math.floor(elapsed / 60);

        const secs = elapsed % 60;

        document.getElementById('timerValue').textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

      }, 100);

    }

    function stopTimer(){

      if (timerInterval) {

        clearInterval(timerInterval);

        timerInterval = null;

      }

    }

    function resetTimer(){

      stopTimer();

      gameStartTime = null;

      document.getElementById('timerValue').textContent = '00:00';

      if (compactTimeout) clearTimeout(compactTimeout);

      compactTimeout = null;

      const ui = document.querySelector('.ui');

      if (ui) ui.classList.remove('compact');

    }

    function rebuildCore(f){

      f = Math.max(1, Math.floor(f)); state.f = f;

      const base = icosahedron(1); const geo  = geodesicSubdivide(base, f, 1);

      state.polys = buildDualPolygons(geo.verts, geo.faces); state.neighbors = buildAdjacency(state.polys);

      // Hide overlays
      const loadingOverlay = document.getElementById('loadingOverlay');
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      if (loadingOverlay) loadingOverlay.classList.remove('visible');
      if (gameOverOverlay) gameOverOverlay.classList.remove('visible');
      
      buildTiles(); state.firstClick = false; state.gameOver=false; state.safeRevealed=0; state.totalMines=0; state.flags=0; state.lives=3; state.won=false; lifeLostInCurrentReveal=false; resetTimer(); updateCounters();
      
      // Reset sphere rotation
      tileGroup.quaternion.identity();
      wireGroup.quaternion.identity();
      rotationVelocity.x = 0;
      rotationVelocity.y = 0;

      // Auto-start: Place mines and do initial reveals
      const ratio = debugSettings.mineRatio || 15;
      const initialReveal = debugSettings.initialRevealPercent || 0;
      const emptyRatio = debugSettings.emptyTilePercent || 0;
      
      // Pick a random starting tile (or use tile 0)
      const startTile = Math.floor(Math.random() * state.tiles.length);
      
      // Reset reveal queue and state
      revealQueue = [];
      revealQueueSet.clear();
      isRevealing = false;
      isInitialReveal = false;
      
      placeMines(startTile, ratio, initialReveal, emptyRatio);

      document.querySelectorAll('.heart').forEach(h => h.style.opacity = '1');

    }



    // Picking

    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();

    let dragState = { isDragging: false, startX: 0, startY: 0, startTile: -1, button: -1, isRotating: false, lastX: 0, lastY: 0, isMouseButtonDown: false, lastMoveTime: 0 };

    let lastClickTime = 0; let lastClickTile = -1; let lastClickTimeout = null;
    
    // Smooth rotation with momentum
    let rotationVelocity = { x: 0, y: 0 };
    const rotationFriction = 0.88; // Friction for momentum decay (0.88 = 12% decay per frame - faster stop)
    const rotationAcceleration = 0.08; // How quickly velocity builds up (0-1) - slower easing in
    const rotationSpeed = 0.0025; // Base rotation speed multiplier - less responsive


    function pickTile(event){

      const rect = renderer.domElement.getBoundingClientRect();

      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera); const hits = raycaster.intersectObjects(tileGroup.children, false);

      if (hits.length===0) return -1; const mesh = hits[0].object; const idx = state.tiles.findIndex(t=>t.mesh===mesh); return idx;

    }



    renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());

    renderer.domElement.addEventListener('mousedown', (e)=>{

      const idx = pickTile(e);

      dragState.isDragging = false;

      dragState.isRotating = false;

      dragState.startX = e.clientX;

      dragState.startY = e.clientY;

      dragState.lastX = e.clientX;

      dragState.lastY = e.clientY;

      dragState.startTile = idx;

      dragState.button = e.button;
      
      if (e.button === 0) {
        dragState.isMouseButtonDown = true;
        dragState.lastMoveTime = performance.now();
      }

    });

    renderer.domElement.addEventListener('mousemove', (e)=>{

      if (dragState.startTile >= 0) {

        const dx = Math.abs(e.clientX - dragState.startX);

        const dy = Math.abs(e.clientY - dragState.startY);

        if (dx > 5 || dy > 5) {

          dragState.isDragging = true;

          if (lastClickTimeout) {

            clearTimeout(lastClickTimeout);

            lastClickTimeout = null;

            lastClickTime = 0;

            lastClickTile = -1;

          }

        }

      }

      // Simple sphere rotation on left mouse drag with momentum
      if (e.buttons === 1) {
        const deltaX = e.clientX - dragState.lastX;
        const deltaY = e.clientY - dragState.lastY;
        
        // Check if we've moved enough to consider it a drag (not just a click)
        const totalDrag = Math.abs(e.clientX - dragState.startX) + Math.abs(e.clientY - dragState.startY);
        
        // Check if mouse is actually moving (not just held down)
        const isMoving = Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1;
        
        if (totalDrag > 5 && isMoving) {
          dragState.isDragging = true;
          dragState.isRotating = true;
          dragState.lastMoveTime = performance.now();
          
          // Build up velocity smoothly (easing in)
          const targetVelocityX = deltaX * rotationSpeed;
          const targetVelocityY = deltaY * rotationSpeed;
          
          rotationVelocity.x += (targetVelocityX - rotationVelocity.x) * rotationAcceleration;
          rotationVelocity.y += (targetVelocityY - rotationVelocity.y) * rotationAcceleration;
        } else {
          // If not actively dragging, stop rotation immediately
          dragState.isRotating = false;
        }
      } else {
        // Mouse released - stop rotation
        dragState.isMouseButtonDown = false;
        dragState.isRotating = false;
      }
      
      dragState.lastX = e.clientX;
      dragState.lastY = e.clientY;

    });

    renderer.domElement.addEventListener('mouseup', (e)=>{
      
      if (e.button === 0) {
        dragState.isMouseButtonDown = false;
        dragState.isRotating = false;
      }

      if (dragState.startTile < 0) return;

      const idx = pickTile(e);

      if (dragState.isDragging || idx !== dragState.startTile) {

        if (lastClickTimeout) {

          clearTimeout(lastClickTimeout);

          lastClickTimeout = null;

        }

        lastClickTime = 0;

        lastClickTile = -1;

        dragState.startTile = -1;

        return;

      }

      if (e.button === 2 && dragState.button === 2) {
        rightClickHandled = true;
        toggleFlag(idx);
        // Clear flag immediately for faster response
        setTimeout(() => { rightClickHandled = false; }, 50);
      } else if (e.button === 0 && dragState.button === 0) {

        const now = Date.now();

        const isDoubleClick = (now - lastClickTime < 300) && (idx === lastClickTile);

        if (isDoubleClick) {

          clearTimeout(lastClickTimeout);

          lastClickTime = 0;

          lastClickTile = -1;

          chord(idx);

        } else {

          // Reveal immediately for instant response
          reveal(idx);

          // Still track for double-click detection, but don't delay the reveal
          lastClickTime = now;

          lastClickTile = idx;

          // Clear after a short delay to allow double-click detection
          lastClickTimeout = setTimeout(() => {

            lastClickTime = 0;

            lastClickTile = -1;

          }, 300);

        }

      }

      dragState.startTile = -1;

    });

    // Touch support for sphere rotation

    let touchState = { isActive: false, lastX: 0, lastY: 0, startTile: -1 };

    renderer.domElement.addEventListener('touchstart', (e) => {

      e.preventDefault();

      if (e.touches.length === 1) {

        const touch = e.touches[0];

        const idx = pickTile({ clientX: touch.clientX, clientY: touch.clientY });

        touchState.isActive = true;

        touchState.lastX = touch.clientX;

        touchState.lastY = touch.clientY;

        touchState.startTile = idx;

      }

    });

    renderer.domElement.addEventListener('touchmove', (e) => {

      e.preventDefault();

      if (e.touches.length === 1 && touchState.isActive) {

        const touch = e.touches[0];

        const deltaX = touch.clientX - touchState.lastX;

        const deltaY = touch.clientY - touchState.lastY;

        // Check if we've moved enough to consider it a drag

        const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        if (dragDistance > 5) {

          // Get camera's local axes in world space (screen-space aligned)
          camera.updateMatrixWorld();
          
          const right = new THREE.Vector3();
          const up = new THREE.Vector3();
          const forward = new THREE.Vector3();
          camera.matrixWorld.extractBasis(right, up, forward);
          
          // Rotate directly based on current movement (no accumulation during drag)
          const currentRotX = deltaX * rotationSpeed;
          const currentRotY = deltaY * rotationSpeed;
          
          // Rotate sphere: drag left = rotate right, drag up = rotate down
          const rotX = new THREE.Quaternion().setFromAxisAngle(up, currentRotX);
          const rotY = new THREE.Quaternion().setFromAxisAngle(right, currentRotY);

          const combinedRot = rotX.multiply(rotY);

          tileGroup.quaternion.premultiply(combinedRot);
          wireGroup.quaternion.premultiply(combinedRot);
          
          // Store velocity for momentum after release (only when actively moving)
          rotationVelocity.x = currentRotX * 0.5; // Scale down for smoother momentum
          rotationVelocity.y = currentRotY * 0.5;

        }

        touchState.lastX = touch.clientX;

        touchState.lastY = touch.clientY;

      }

    });

    renderer.domElement.addEventListener('touchend', (e) => {

      e.preventDefault();

      if (touchState.isActive && touchState.startTile >= 0 && e.changedTouches.length > 0) {

        const touch = e.changedTouches[0];

        const finalX = touch.clientX;

        const finalY = touch.clientY;

        const dragDistance = Math.sqrt(Math.pow(finalX - touchState.lastX, 2) + Math.pow(finalY - touchState.lastY, 2));

        // Only process tile click if we didn't drag much

        if (dragDistance < 10) {

          const idx = pickTile({ clientX: finalX, clientY: finalY });

          if (idx === touchState.startTile && idx >= 0) {

            toggleFlag(idx); // Touch is typically used for flagging in mobile

          }

        }

      }

      touchState.isActive = false;

      touchState.startTile = -1;

    });



    // Self-tests

    function runTests(){

      const statusEl = document.getElementById('testStatus'); const results = [];

      function assert(name, cond){ results.push({name, pass: !!cond}); if(!cond) console.error('Test failed:', name); }

      for (let f=1; f<=6; f++){

        const base = icosahedron(1); const geo  = geodesicSubdivide(base, f, 1); const polys = buildDualPolygons(geo.verts, geo.faces); const neigh = buildAdjacency(polys);

        const counts = polys.reduce((acc,p)=>{ acc.total++; acc['n'+p.length]=(acc['n'+p.length]||0)+1; return acc; }, {total:0});

        assert(`f=${f}: pentagons==12`, counts.n5 === 12);

        assert(`f=${f}: only hex/pent`, (counts.n5||0) + (counts.n6||0) === polys.length);

        assert(`f=${f}: tiles==10 f^2 + 2`, polys.length === 10*f*f + 2);

        const degOK = neigh.every((ns, i)=> (polys[i].length===5 ? ns.length===5 : (ns.length===6)) ); assert(`f=${f}: degrees 5/6`, degOK);

      }

      const failed = results.filter(r=>!r.pass).length;

      const message = failed===0 ? `All ${results.length} tests passed` : `${failed}/${results.length} tests failed`;

      if (statusEl) {

        statusEl.textContent = message;

        statusEl.className = 'pill ' + (failed===0 ? 'ok' : 'bad');

      } else {

        console.log('Tests:', message);

      }

    }



    // Sound System using Web Audio API (matching HexaSweeper exactly)
    let soundEnabled = true;
    let audioContext = null;
    let clickSoundStyle = 5; // 1-5: Gentle Tap, Deep Thud, Glass Tinkle, Metallic Tick, Soft Chime (default 5)
    let gameOverSoundStyle = 1; // 1-5: Deep Explosion, Electric Buzz, Bass Drop, Metallic Crash, Quick Pop
    let clickBuffers = new Map(); // Cache for click sound buffers

    // Initialize audio context (requires user interaction)
    function initAudioContext() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          // Pre-create all click sounds asynchronously to avoid blocking initialization
          // Use setTimeout to defer to next event loop tick for faster response
          setTimeout(() => {
            createAllClickSounds();
          }, 0);
        } catch (e) {
          console.warn('Web Audio API not supported');
        }
      }
      return audioContext;
    }

    // Get audio context (for external use)
    function getAudioContext() {
      return audioContext;
    }

    // Set audio enabled state
    function setAudioEnabled(enabled) {
      soundEnabled = enabled;
    }

    // Set click sound style (1-5)
    function setClickSoundStyle(style) {
      clickSoundStyle = Math.max(1, Math.min(5, Math.round(style)));
      // Create buffer if it doesn't exist
      if (!clickBuffers.has(clickSoundStyle)) {
        const buffer = createClickSound(clickSoundStyle);
        if (buffer) {
          clickBuffers.set(clickSoundStyle, buffer);
        }
      }
    }

    // Get click sound style
    function getClickSoundStyle() {
      return clickSoundStyle;
    }

    // Set game over sound style (1-5)
    function setGameOverSoundStyle(style) {
      gameOverSoundStyle = Math.max(1, Math.min(5, Math.round(style)));
    }

    // Get game over sound style
    function getGameOverSoundStyle() {
      return gameOverSoundStyle;
    }

    // Create all click sound buffers
    async function createAllClickSounds() {
      if (!audioContext) return;
      for (let i = 1; i <= 5; i++) {
        const buffer = createClickSound(i);
        if (buffer) {
          clickBuffers.set(i, buffer);
        }
      }
    }

    // Create a click sound buffer (exact HexaSweeper algorithm)
    function createClickSound(style) {
      if (!audioContext) return null;
      const sampleRate = audioContext.sampleRate;
      let duration, buffer, data;
      
      switch (style) {
        case 1: // Gentle Tap
          duration = 0.02;
          buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
          data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 100);
            const freq = 2000;
            data[i] = Math.sin(2 * Math.PI * freq * t) * envelope * 0.2; // Increased from 0.08
          }
          break;
          
        case 2: // Deep Thud
          duration = 0.04;
          buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
          data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 35);
            const wave1 = Math.sin(2 * Math.PI * 120 * t) * Math.exp(-t * 25) * 0.15;
            const wave2 = Math.sin(2 * Math.PI * 80 * t) * 0.08;
            const wave3 = Math.sin(2 * Math.PI * 500 * t) * Math.exp(-t * 80) * 0.05;
            data[i] = (wave1 + wave2 + wave3) * envelope * 0.25; // Increased from 0.12
          }
          break;
          
        case 3: // Glass Tinkle
          duration = 0.05;
          buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
          data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 25);
            const wave1 = Math.sin(2 * Math.PI * 1200 * t) * Math.exp(-t * 30) * 0.1;
            const wave2 = Math.sin(2 * Math.PI * 1500 * t) * Math.exp(-t * 35) * 0.08;
            const wave3 = Math.sin(2 * Math.PI * 1800 * t) * Math.exp(-t * 40) * 0.06;
            const wave4 = Math.sin(2 * Math.PI * 2000 * t) * Math.exp(-t * 20) * 0.04;
            data[i] = (wave1 + wave2 + wave3 + wave4) * envelope * 0.2; // Increased from 0.1
          }
          break;
          
        case 4: // Metallic Tick
          duration = 0.015;
          buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
          data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 120);
            const wave1 = Math.sin(2 * Math.PI * 1500 * t) * Math.exp(-t * 100) * 0.1;
            const wave2 = Math.sin(2 * Math.PI * 2000 * t) * Math.exp(-t * 80) * 0.05;
            data[i] = (wave1 + wave2) * envelope * 0.2; // Increased from 0.1
          }
          break;
          
        case 5: // Soft Chime
          duration = 0.04;
          buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
          data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 40);
            const wave1 = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-t * 30) * 0.08;
            const wave2 = Math.sin(2 * Math.PI * 1200 * t) * Math.exp(-t * 35) * 0.06;
            const wave3 = Math.sin(2 * Math.PI * 1500 * t) * Math.exp(-t * 40) * 0.04;
            data[i] = (wave1 + wave2 + wave3) * envelope * 0.2; // Increased from 0.1
          }
          break;
          
        default:
          return null;
      }
      
      return buffer;
    }

    // Play a buffer
    function playBuffer(buffer) {
      if (!audioContext || !buffer) return;
      try {
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
      } catch (e) {
        console.warn('Could not play sound:', e);
      }
    }

    // Play click sound based on style (exact HexaSweeper implementation)
    function playClick() {
      if (!soundEnabled) return;
      
      if (!audioContext) {
        initAudioContext().then(() => {
          playClickInternal();
        }).catch(() => {});
        return;
      }
      
      if (audioContext.state === 'suspended') {
        const style = clickSoundStyle;
        audioContext.resume().then(() => {
          playClickInternal(style);
        }).catch(() => {});
        return;
      }
      
      playClickInternal();
    }

    function playClickInternal(styleOverride) {
      if (!audioContext) return;
      const style = styleOverride !== undefined ? styleOverride : clickSoundStyle;
      
      let buffer = clickBuffers.get(style);
      if (!buffer) {
        buffer = createClickSound(style);
        if (buffer) {
          clickBuffers.set(style, buffer);
        } else {
          // Fallback to style 1
          buffer = clickBuffers.get(1);
          if (!buffer) {
            buffer = createClickSound(1);
            if (buffer) clickBuffers.set(1, buffer);
            else return;
          }
        }
      }
      
      playBuffer(buffer);
    }

    // Play game over sound based on style (exact HexaSweeper implementation)
    function playGameOver() {
      if (!soundEnabled) {
        console.log('Audio disabled, skipping game over sound');
        return;
      }
      
      if (!audioContext) {
        initAudioContext().then(() => {
          playGameOverProceduralInternalWithStyle(gameOverSoundStyle);
        }).catch(() => {});
        return;
      }
      
      try {
        const style = gameOverSoundStyle;
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            playGameOverProceduralInternalWithStyle(style);
          }).catch((e) => {
            console.warn('Could not resume AudioContext:', e);
          });
          return;
        }
        playGameOverProceduralInternalWithStyle(style);
      } catch (e) {
        console.warn('Could not play game over sound:', e);
      }
    }

    function playGameOverProceduralInternalWithStyle(style) {
      if (!audioContext) {
        console.warn('AudioContext not available for game over sound');
        return;
      }
      
      try {
        const sampleRate = audioContext.sampleRate;
        let buffer, data;
        
        switch (style) {
          case 1: // Deep Explosion
            buffer = audioContext.createBuffer(1, sampleRate * 0.8, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = t < 0.1 ? t / 0.1 : Math.exp(-(t - 0.1) * 8);
              const wave1 = Math.sin(2 * Math.PI * 60 * t) * 0.4;
              const wave2 = Math.sin(2 * Math.PI * 200 * t * (1 + t * 2)) * 0.3;
              const noise = (Math.random() * 2 - 1) * 0.3;
              const pop = t < 0.2 ? Math.sin(2 * Math.PI * 800 * t) * (1 - t * 5) * 0.2 : 0;
              data[i] = (wave1 + wave2 + noise * (1 - t * 1.2) + pop) * envelope * 0.1; // Further decreased from 0.15
            }
            break;
            
          case 2: // Electric Buzz
            buffer = audioContext.createBuffer(1, sampleRate * 0.5, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = Math.exp(-t * 15);
              const wave1 = Math.sin(2 * Math.PI * 400 * t) * Math.exp(-t * 30) * 0.6;
              const wave2 = Math.sin(2 * Math.PI * 1200 * t * (1 + t * 4)) * 0.4;
              const noise = (Math.random() * 2 - 1) * Math.exp(-t * 20) * 0.5;
              const wave3 = Math.sin(2 * Math.PI * 3000 * t) * Math.exp(-t * 40) * 0.3;
              data[i] = (wave1 + wave2 + noise * (1 - t * 2) + wave3) * envelope * 0.12; // Further decreased from 0.18
            }
            break;
            
          case 3: // Bass Drop
            buffer = audioContext.createBuffer(1, sampleRate * 1.0, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = Math.exp(-t * 4);
              const freq = 90 - t * 50;
              const wave1 = Math.sin(2 * Math.PI * freq * t) * 0.7;
              const wave2 = Math.sin(2 * Math.PI * 45 * t) * 0.4;
              const wave3 = Math.sin(2 * Math.PI * 180 * t) * Math.exp(-t * 12) * 0.4;
              const wave4 = t < 0.3 ? Math.sin(2 * Math.PI * 500 * t) * Math.exp(-t * 25) * 0.3 : 0;
              data[i] = (wave1 + wave2 + wave3 + wave4) * envelope * 0.12; // Further decreased from 0.18
            }
            break;
            
          case 4: // Metallic Crash
            buffer = audioContext.createBuffer(1, sampleRate * 0.9, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = t < 0.03 ? t / 0.03 : Math.exp(-(t - 0.03) * 8);
              const wave1 = Math.sin(2 * Math.PI * 600 * t) * Math.exp(-t * 35) * 0.6;
              const wave2 = Math.sin(2 * Math.PI * 350 * t) * Math.exp(-t * 4) * 0.5;
              const wave3 = Math.sin(2 * Math.PI * 700 * t) * Math.exp(-t * 7) * 0.4;
              const wave4 = Math.sin(2 * Math.PI * 1400 * t) * Math.exp(-t * 10) * 0.3;
              const wave5 = t > 0.2 ? Math.sin(2 * Math.PI * 400 * (t - 0.2)) * Math.exp(-(t - 0.2) * 8) * 0.2 : 0;
              const noise = (Math.random() * 2 - 1) * Math.exp(-t * 25) * 0.25;
              data[i] = (wave1 + wave2 + wave3 + wave4 + wave5 + noise * (1 - t * 1.5)) * envelope * 0.1; // Further decreased from 0.15
            }
            break;
            
          case 5: // Quick Pop
            buffer = audioContext.createBuffer(1, sampleRate * 0.4, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = t < 0.05 ? t / 0.05 : Math.exp(-t * 20);
              const wave1 = Math.sin(2 * Math.PI * 250 * t) * Math.exp(-t * 45) * 0.7;
              const wave2 = Math.sin(2 * Math.PI * 1200 * t) * Math.exp(-t * 60) * 0.5;
              const noise = (Math.random() * 2 - 1) * Math.exp(-t * 35) * 0.4;
              const wave3 = t > 0.1 ? Math.sin(2 * Math.PI * 300 * (t - 0.1)) * Math.exp(-(t - 0.1) * 15) * 0.2 : 0;
              data[i] = (wave1 + wave2 + noise * (1 - t * 3) + wave3) * envelope * 0.13; // Further decreased from 0.2
            }
            break;
            
          default:
            // Fallback to style 1
            buffer = audioContext.createBuffer(1, sampleRate * 0.8, sampleRate);
            data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / sampleRate;
              const envelope = t < 0.1 ? t / 0.1 : Math.exp(-(t - 0.1) * 8);
              const wave1 = Math.sin(2 * Math.PI * 60 * t) * 0.4;
              const wave2 = Math.sin(2 * Math.PI * 200 * t * (1 + t * 2)) * 0.3;
              const noise = (Math.random() * 2 - 1) * 0.3;
              data[i] = (wave1 + wave2 + noise * (1 - t * 1.2)) * envelope * 0.1; // Further decreased from 0.15
            }
        }
        
        playBuffer(buffer);
      } catch (e) {
        console.warn('Could not play procedural game over sound:', e);
      }
    }

    // Play victory sound (exact HexaSweeper implementation)
    function playVictory() {
      if (!soundEnabled) return;
      
      if (!audioContext) {
        initAudioContext().then(() => {
          playVictoryInternal();
        }).catch(() => {});
        return;
      }
      
      playVictoryInternal();
    }

    function playVictoryInternal() {
      if (!audioContext) return;
      
      try {
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, sampleRate * 1.5, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          const t = i / sampleRate;
          const envelope = Math.exp(-t * 2);
          const wave1 = Math.sin(2 * Math.PI * 523.25 * t) * 0.3;
          const wave2 = Math.sin(2 * Math.PI * 659.25 * t) * 0.3;
          const wave3 = Math.sin(2 * Math.PI * 783.99 * t) * 0.3;
          const wave4 = Math.sin(2 * Math.PI * 523.25 * 2 * t) * 0.1;
          const wave5 = Math.sin(2 * Math.PI * 659.25 * 2 * t) * 0.1;
          data[i] = (wave1 + wave2 + wave3 + wave4 + wave5) * envelope * 0.15;
        }
        
        playBuffer(buffer);
      } catch (e) {
        console.warn('Could not play victory sound:', e);
      }
    }

    // Play a sound using Web Audio API (legacy function for compatibility)
    function playSound(type) {
      if (!soundEnabled || !audioContext) return;

      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        const now = audioContext.currentTime;
        
        switch (type) {
          case 'reveal':
            playClick();
            break;
          case 'flag':
            playClick();
            break;
          case 'unflag':
            playClick();
            break;
          case 'mine':
            playGameOver();
            break;
          case 'win':
            playVictory();
            break;
          case 'lifeLost':
            playGameOver();
            break;
        }
      } catch (e) {
        console.warn('Error playing sound:', e);
      }
    }

    // Initialize audio context on first user interaction
    document.addEventListener('click', () => {
      initAudioContext();
    }, { once: true });

    document.addEventListener('touchstart', () => {
      initAudioContext();
    }, { once: true });

    // UI

    document.getElementById('newGame').addEventListener('click', ()=>{ 
      initAudioContext();
      // Hide game over overlay if visible
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      if (gameOverOverlay) {
        gameOverOverlay.classList.remove('visible');
      }
      rebuildCore(state.f); 
    });

    // Restart button in game over overlay
    document.getElementById('restartButton').addEventListener('click', ()=>{ 
      initAudioContext();
      // Hide game over overlay
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      if (gameOverOverlay) {
        gameOverOverlay.classList.remove('visible');
      }
      rebuildCore(state.f); 
    });

    document.getElementById('soundToggle').addEventListener('click', (e)=>{
      initAudioContext();
      setAudioEnabled(!soundEnabled);
      e.target.textContent = soundEnabled ? 'üîä' : 'üîá';
    });

    document.getElementById('globeBtn').addEventListener('click', ()=>{

      camera.position.set(0, 0, 3.4);

      controls.reset();
      
      // Reset sphere rotation
      tileGroup.quaternion.identity();
      wireGroup.quaternion.identity();
      rotationVelocity.x = 0;
      rotationVelocity.y = 0;

    });



    // Debug Panel

    const debugPanel = document.getElementById('debugPanel');

    const debugToggle = document.getElementById('debugToggle');

    let debugPanelVisible = false;

    function toggleDebugPanel() {

      debugPanelVisible = !debugPanelVisible;

      debugPanel.classList.toggle('visible', debugPanelVisible);

    }

    debugToggle.addEventListener('click', toggleDebugPanel);

    addEventListener('keydown', (e) => {

      if (e.ctrlKey && e.shiftKey && e.altKey && e.key === 'd') {

        e.preventDefault();

        toggleDebugPanel();

      }

    });

    function saveDebugValuesToClipboard() {

      const debugValues = {};

      // Collect all range inputs
      document.querySelectorAll('#debugPanel input[type="range"]').forEach(input => {

        const id = input.id;

        if (id && id.startsWith('debug')) {

          const key = id.replace('debug', '').replace(/^[A-Z]/, (match) => match.toLowerCase());

          const value = parseFloat(input.value);

          debugValues[key] = isNaN(value) ? input.value : value;

        }

      });

      // Collect all color inputs
      document.querySelectorAll('#debugPanel input[type="color"]').forEach(input => {

        const id = input.id;

        if (id && id.startsWith('debug')) {

          const key = id.replace('debug', '').replace(/^[A-Z]/, (match) => match.toLowerCase());

          debugValues[key] = input.value;

        }

      });

      // Collect all checkboxes
      document.querySelectorAll('#debugPanel input[type="checkbox"]').forEach(input => {

        const id = input.id;

        if (id && id.startsWith('debug')) {

          const key = id.replace('debug', '').replace(/^[A-Z]/, (match) => match.toLowerCase());

          debugValues[key] = input.checked;

        }

      });

      // Format as JSON with nice indentation
      const jsonString = JSON.stringify(debugValues, null, 2);

      // Copy to clipboard
      navigator.clipboard.writeText(jsonString).then(() => {

        const btn = document.getElementById('debugSaveClipboard');

        const originalText = btn.textContent;

        btn.textContent = '‚úì Copied!';

        setTimeout(() => {

          btn.textContent = originalText;

        }, 2000);

      }).catch(err => {

        console.error('Failed to copy to clipboard:', err);

        alert('Failed to copy to clipboard. Please check console for details.');

      });

    }

    function loadDebugValuesFromClipboard() {

      navigator.clipboard.readText().then(text => {

        try {

          const values = JSON.parse(text);

          // Map of JSON keys to input IDs (without 'debug' prefix)
          const keyToInputId = {
            'freq': 'debugFreq',
            'mineRatio': 'debugMineRatio',
            'emptyRatio': 'debugEmptyRatio',
            'initialReveal': 'debugInitialReveal',
            'glass': 'debugGlass',
            'glassTint': 'debugGlassTint',
            'wireHex': 'debugWireHex',
            'wirePent': 'debugWirePent',
            'tileHidden': 'debugTileHidden',
            'tileRevealed': 'debugTileRevealed',
            'tileFlag': 'debugTileFlag',
            'tileMine': 'debugTileMine',
            'labelOffset': 'debugLabelOffset',
            'labelRot': 'debugLabelRot',
            'labelRotX': 'debugLabelRotX',
            'labelRotY': 'debugLabelRotY',
            'labelRotZ': 'debugLabelRotZ',
            'labelScale': 'debugLabelScale',
            'labelColor': 'debugLabelColor',
            'camFOV': 'debugCamFOV',
            'camX': 'debugCamX',
            'camY': 'debugCamY',
            'camZ': 'debugCamZ',
            'camNear': 'debugCamNear',
            'camFar': 'debugCamFar',
            'camBg': 'debugCamBg',
            'immortal': 'debugImmortal',
            'camFog': 'debugCamFog'
          };

          // Set range inputs
          Object.keys(values).forEach(key => {

            const inputId = keyToInputId[key];

            if (!inputId) return;

            const input = document.getElementById(inputId);

            if (input && input.type === 'range') {

              input.value = values[key];

              // Trigger input event to update dependent values
              input.dispatchEvent(new Event('input', { bubbles: true }));

            } else if (input && input.type === 'color') {

              input.value = values[key];

              // Find and update display and hex span
              const displayId = inputId + 'Display';

              const hexId = inputId + 'Hex';

              const display = document.getElementById(displayId);

              const hexSpan = document.getElementById(hexId);

              if (display && hexSpan) {

                updateColorDisplay(input, display, hexSpan);

              }

              // Trigger input event
              input.dispatchEvent(new Event('input', { bubbles: true }));

            } else if (input && input.type === 'checkbox') {

              input.checked = values[key];

              // Trigger change event
              input.dispatchEvent(new Event('change', { bubbles: true }));

            }

          });

          // Special handling for freq (rebuilds core)
          if (values.freq !== undefined) {

            const freqSlider = document.getElementById('debugFreq');

            if (freqSlider) {

              freqSlider.value = values.freq;

              syncSliderValue(freqSlider, document.getElementById('debugFreqValue'));

              rebuildCore(parseInt(values.freq, 10));

            }

          }

          // Show success feedback
          const btn = document.getElementById('debugLoadClipboard');

          const originalText = btn.textContent;

          btn.textContent = '‚úì Loaded!';

          setTimeout(() => {

            btn.textContent = originalText;

          }, 2000);

        } catch (err) {

          console.error('Failed to parse JSON:', err);

          alert('Failed to parse JSON from clipboard. Please ensure valid JSON format.');

        }

      }).catch(err => {

        console.error('Failed to read from clipboard:', err);

        alert('Failed to read from clipboard. Please ensure clipboard contains valid JSON.');

      });

    }

    document.getElementById('debugSaveClipboard').addEventListener('click', saveDebugValuesToClipboard);

    document.getElementById('debugLoadClipboard').addEventListener('click', loadDebugValuesFromClipboard);

    document.getElementById('debugCloseBtn').addEventListener('click', toggleDebugPanel);

    document.querySelectorAll('.debug-section-header').forEach(header => {

      header.addEventListener('click', () => {

        const section = header.parentElement;

        section.classList.toggle('collapsed');

        header.classList.toggle('collapsed');

      });

    });

    function updateSliderFill(slider) {

      const val = parseFloat(slider.value);

      const min = parseFloat(slider.min);

      const max = parseFloat(slider.max);

      const percent = ((val - min) / (max - min)) * 100;

      slider.style.setProperty('--fill', `${percent}%`);

    }

    function syncSliderValue(slider, valueInput) {

      updateSliderFill(slider);

      valueInput.value = slider.value;

    }

    function updateColorDisplay(colorInput, display, hexSpan) {

      const color = colorInput.value;

      display.style.background = color;

      hexSpan.textContent = color;

    }

    const freqSlider = document.getElementById('debugFreq');

    const freqValue = document.getElementById('debugFreqValue');

    freqSlider.addEventListener('input', (e) => {

      const val = parseInt(e.target.value, 10);

      syncSliderValue(freqSlider, freqValue);

      rebuildCore(val);

    });

    const mineRatioSlider = document.getElementById('debugMineRatio');

    const mineRatioValue = document.getElementById('debugMineRatioValue');

    mineRatioSlider.addEventListener('input', (e) => {

      const val = parseInt(e.target.value, 10);

      debugSettings.mineRatio = val;

      syncSliderValue(mineRatioSlider, mineRatioValue);

    });

    const initialRevealSlider = document.getElementById('debugInitialReveal');

    const initialRevealValue = document.getElementById('debugInitialRevealValue');

    initialRevealSlider.addEventListener('input', (e) => {

      debugSettings.initialRevealPercent = parseInt(e.target.value, 10);

      syncSliderValue(initialRevealSlider, initialRevealValue);

    });

    const emptyRatioSlider = document.getElementById('debugEmptyRatio');

    const emptyRatioValue = document.getElementById('debugEmptyRatioValue');

    emptyRatioSlider.addEventListener('input', (e) => {

      debugSettings.emptyTilePercent = parseInt(e.target.value, 10);

      syncSliderValue(emptyRatioSlider, emptyRatioValue);

      // Apply empty tiles immediately if mines are already placed
      if (state.totalMines > 0 && !state.firstClick) {

        const totalTiles = state.tiles.length;

        const emptyCount = Math.floor(totalTiles * debugSettings.emptyTilePercent / 100);

        // Get all non-mine tile indices
        const nonMineIndices = [...state.tiles.keys()].filter(i => !state.tiles[i].mine);

        // Shuffle array using Fisher-Yates
        for (let i = nonMineIndices.length - 1; i > 0; i--) {

          const j = Math.floor(Math.random() * (i + 1));

          [nonMineIndices[i], nonMineIndices[j]] = [nonMineIndices[j], nonMineIndices[i]];

        }

        // Create a set of empty tile indices for quick lookup
        const emptyTileIndices = new Set();

        for (let i = 0; i < emptyCount && i < nonMineIndices.length; i++) {

          const idx = nonMineIndices[i];

          emptyTileIndices.add(idx);

          state.tiles[idx].count = 0;

          state.tiles[idx].isEmpty = true;
          
          // Apply transparent material to empty tiles (always visible and transparent)
          state.tiles[idx].mesh.material = matEmpty; // Share material for empty tiles

          // Update label if tile is revealed (remove number label for empty tiles)
          if (state.tiles[idx].revealed && state.tiles[idx].label) {

            tileGroup.remove(state.tiles[idx].label);

            state.tiles[idx].label.material.map.dispose();

            state.tiles[idx].label.material.dispose();

            state.tiles[idx].label = null;

          }

        }

        // Recalculate counts for non-empty tiles
        state.tiles.forEach((t, i) => {

          if (t.mine) return;

          // Skip if this tile was set to empty
          if (emptyTileIndices.has(i)) return;

          // Mark as non-empty if it was previously empty
          state.tiles[i].isEmpty = false;

          let c = 0;

          for (const nb of state.neighbors[i]) {

            if (state.tiles[nb].mine) c++;

          }

          t.count = c;

          // Update label if tile is revealed
          if (t.revealed) {

            // Update material to non-empty (since it's no longer empty)
            t.mesh.material = matRevealed;

            if (t.label) {

              tileGroup.remove(t.label);

              t.label.material.map.dispose();

              t.label.material.dispose();

              t.label = null;

            }

            if (t.count > 0 && !t.isEmpty) {

              // Get label color, or calculate it from revealed tile color if not set
              let labelColorHex = document.getElementById('debugLabelColor')?.value;
              if (!labelColorHex) {
                const revealedColor = document.getElementById('debugTileRevealed')?.value || '#4c5b7b';
                labelColorHex = lightenColor(revealedColor, 0.55);
              }

              const s = makeNumberSprite(t.count, labelScale(state.f), labelColorHex);

              s.position.copy(t.center).multiplyScalar(debugSettings.labelOffset || 1.015);

              tileGroup.add(s);

              t.label = s;

            }

          }

        });
        
        // Rebuild wireframe to hide edges between empty tiles
        rebuildWireframe();

      }

    });

    const glassSlider = document.getElementById('debugGlass');

    const glassValue = document.getElementById('debugGlassValue');

    glassSlider.addEventListener('input', (e) => {

      syncSliderValue(glassSlider, glassValue);

      const opacity = parseFloat(glassSlider.value);

      const tintColor = glassTintInput.value;

      state.tiles.forEach(t => {

        // Only affect hidden, non-empty, non-flagged tiles
        if (!t.revealed && !t.flagged && !t.isEmpty) {

          t.mesh.material.opacity = 1 - opacity;

          t.mesh.material.transparent = opacity > 0;

          if (opacity > 0) {

            const tint = parseInt(tintColor.substring(1), 16);

            t.mesh.material.color.setHex(tint);

          } else {

            t.mesh.material.color.copy(matHidden.color);

          }

        }

      });

    });

    const glassTintInput = document.getElementById('debugGlassTint');

    const glassTintDisplay = document.getElementById('debugGlassTintDisplay');

    const glassTintHex = document.getElementById('debugGlassTintHex');

    glassTintDisplay.addEventListener('click', () => glassTintInput.click());

    glassTintInput.addEventListener('input', (e) => {

      updateColorDisplay(glassTintInput, glassTintDisplay, glassTintHex);

      const opacity = parseFloat(glassSlider.value);

      if (opacity > 0) {

        const tint = parseInt(glassTintInput.value.substring(1), 16);

        state.tiles.forEach(t => {

          // Only affect hidden, non-empty, non-flagged tiles
          if (!t.revealed && !t.flagged && !t.isEmpty) {

            t.mesh.material.color.setHex(tint);

          }

        });

      }

    });

    const wireHexInput = document.getElementById('debugWireHex');

    const wireHexDisplay = document.getElementById('debugWireHexDisplay');

    const wireHexHex = document.getElementById('debugWireHexHex');

    wireHexDisplay.addEventListener('click', () => wireHexInput.click());

    wireHexInput.addEventListener('input', (e) => {

      updateColorDisplay(wireHexInput, wireHexDisplay, wireHexHex);

      const color = parseInt(wireHexInput.value.substring(1), 16);

      if (wireHexMaterial) wireHexMaterial.color.setHex(color);

    });

    const wirePentInput = document.getElementById('debugWirePent');

    const wirePentDisplay = document.getElementById('debugWirePentDisplay');

    const wirePentHex = document.getElementById('debugWirePentHex');

    wirePentDisplay.addEventListener('click', () => wirePentInput.click());

    wirePentInput.addEventListener('input', (e) => {

      updateColorDisplay(wirePentInput, wirePentDisplay, wirePentHex);

      const color = parseInt(wirePentInput.value.substring(1), 16);

      if (wirePentMaterial) wirePentMaterial.color.setHex(color);

    });

    const tileHiddenInput = document.getElementById('debugTileHidden');

    const tileHiddenDisplay = document.getElementById('debugTileHiddenDisplay');

    const tileHiddenHex = document.getElementById('debugTileHiddenHex');

    tileHiddenDisplay.addEventListener('click', () => tileHiddenInput.click());

    tileHiddenInput.addEventListener('input', (e) => {

      updateColorDisplay(tileHiddenInput, tileHiddenDisplay, tileHiddenHex);

      matHidden.color.setHex(parseInt(tileHiddenInput.value.substring(1), 16));

      state.tiles.forEach(t => { if (!t.revealed && !t.flagged) t.mesh.material.color.copy(matHidden.color); });

    });

    const tileRevealedInput = document.getElementById('debugTileRevealed');

    const tileRevealedDisplay = document.getElementById('debugTileRevealedDisplay');

    const tileRevealedHex = document.getElementById('debugTileRevealedHex');

    tileRevealedDisplay.addEventListener('click', () => tileRevealedInput.click());

    tileRevealedInput.addEventListener('input', (e) => {

      updateColorDisplay(tileRevealedInput, tileRevealedDisplay, tileRevealedHex);

      matRevealed.color.setHex(parseInt(tileRevealedInput.value.substring(1), 16));

      state.tiles.forEach(t => { if (t.revealed && !t.mine) t.mesh.material.color.copy(matRevealed.color); });

      // Automatically update label color to be a lighter tone of revealed tile color
      const lighterColor = lightenColor(tileRevealedInput.value, 0.55);
      if (labelColorInput) {
        labelColorInput.value = lighterColor;
        updateColorDisplay(labelColorInput, labelColorDisplay, labelColorHex);
        // Update all existing labels
        state.tiles.forEach(t => {
          if (t.label && t.count > 0 && !t.isEmpty) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0,0,128,128);
            ctx.font = '700 72px system-ui, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = lighterColor;
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 8;
            ctx.fillText(String(t.count), 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 4;
            tex.needsUpdate = true;
            t.label.material.map.dispose();
            t.label.material.map = tex;
            t.label.material.needsUpdate = true;
          }
        });
      }

    });

    const tileFlagInput = document.getElementById('debugTileFlag');

    const tileFlagDisplay = document.getElementById('debugTileFlagDisplay');

    const tileFlagHex = document.getElementById('debugTileFlagHex');

    tileFlagDisplay.addEventListener('click', () => tileFlagInput.click());

    tileFlagInput.addEventListener('input', (e) => {

      updateColorDisplay(tileFlagInput, tileFlagDisplay, tileFlagHex);

      matFlag.color.setHex(parseInt(tileFlagInput.value.substring(1), 16));

      state.tiles.forEach(t => { if (t.flagged) t.mesh.material.color.copy(matFlag.color); });

    });

    const tileMineInput = document.getElementById('debugTileMine');

    const tileMineDisplay = document.getElementById('debugTileMineDisplay');

    const tileMineHex = document.getElementById('debugTileMineHex');

    tileMineDisplay.addEventListener('click', () => tileMineInput.click());

    tileMineInput.addEventListener('input', (e) => {

      updateColorDisplay(tileMineInput, tileMineDisplay, tileMineHex);

      matMine.color.setHex(parseInt(tileMineInput.value.substring(1), 16));

      state.tiles.forEach(t => { if (t.mine && t.revealed) t.mesh.material.color.copy(matMine.color); });

    });

    const labelOffsetSlider = document.getElementById('debugLabelOffset');

    const labelOffsetValue = document.getElementById('debugLabelOffsetValue');

    function updateAllLabels() {

      const offset = parseFloat(labelOffsetSlider.value);

      const rot = parseFloat(labelRotSlider.value) * Math.PI / 180;

      const rotX = parseFloat(labelRotXSlider.value) * Math.PI / 180;

      const rotY = parseFloat(labelRotYSlider.value) * Math.PI / 180;

      const rotZ = parseFloat(labelRotZSlider.value) * Math.PI / 180;

      const scale = parseFloat(labelScaleSlider.value);

      state.tiles.forEach(t => {

        if (t.label) {

          t.label.position.copy(t.center).multiplyScalar(offset);

          t.label.rotation.set(rotX, rotY, rotZ);

          t.label.rotation.z += rot;

          t.label.scale.set(scale, scale, scale);

        }

      });

    }

    labelOffsetSlider.addEventListener('input', (e) => { syncSliderValue(labelOffsetSlider, labelOffsetValue); updateAllLabels(); });

    const labelRotSlider = document.getElementById('debugLabelRot');

    const labelRotValue = document.getElementById('debugLabelRotValue');

    labelRotSlider.addEventListener('input', (e) => { syncSliderValue(labelRotSlider, labelRotValue); updateAllLabels(); });

    const labelRotXSlider = document.getElementById('debugLabelRotX');

    const labelRotXValue = document.getElementById('debugLabelRotXValue');

    labelRotXSlider.addEventListener('input', (e) => { syncSliderValue(labelRotXSlider, labelRotXValue); updateAllLabels(); });

    const labelRotYSlider = document.getElementById('debugLabelRotY');

    const labelRotYValue = document.getElementById('debugLabelRotYValue');

    labelRotYSlider.addEventListener('input', (e) => { syncSliderValue(labelRotYSlider, labelRotYValue); updateAllLabels(); });

    const labelRotZSlider = document.getElementById('debugLabelRotZ');

    const labelRotZValue = document.getElementById('debugLabelRotZValue');

    labelRotZSlider.addEventListener('input', (e) => { syncSliderValue(labelRotZSlider, labelRotZValue); updateAllLabels(); });

    const labelScaleSlider = document.getElementById('debugLabelScale');

    const labelScaleValue = document.getElementById('debugLabelScaleValue');

    labelScaleSlider.addEventListener('input', (e) => { syncSliderValue(labelScaleSlider, labelScaleValue); updateAllLabels(); });

    const labelColorInput = document.getElementById('debugLabelColor');

    const labelColorDisplay = document.getElementById('debugLabelColorDisplay');

    const labelColorHex = document.getElementById('debugLabelColorHex');

    // Initialize label color based on revealed tile color on page load
    if (tileRevealedInput && labelColorInput) {
      const initialLighterColor = lightenColor(tileRevealedInput.value, 0.55);
      labelColorInput.value = initialLighterColor;
      updateColorDisplay(labelColorInput, labelColorDisplay, labelColorHex);
    }

    labelColorDisplay.addEventListener('click', () => labelColorInput.click());

    labelColorInput.addEventListener('input', (e) => {

      updateColorDisplay(labelColorInput, labelColorDisplay, labelColorHex);

      const color = labelColorInput.value;

      state.tiles.forEach(t => {

        if (t.label && t.count > 0 && !t.isEmpty) {

          const canvas = document.createElement('canvas');

          canvas.width = 128; canvas.height = 128;

          const ctx = canvas.getContext('2d');

          ctx.fillStyle = 'rgba(0,0,0,0)';

          ctx.fillRect(0,0,128,128);

          ctx.font = '700 72px system-ui, Arial';

          ctx.textAlign = 'center';

          ctx.textBaseline = 'middle';

          ctx.fillStyle = color;

          ctx.shadowColor = 'rgba(0,0,0,0.5)';

          ctx.shadowBlur = 8;

          ctx.fillText(String(t.count), 64, 64);

          t.label.material.map.dispose();

          t.label.material.map = new THREE.CanvasTexture(canvas);

          t.label.material.map.anisotropy = 4;

          t.label.material.map.needsUpdate = true;

        }

      });

    });

    const camBgInput = document.getElementById('debugCamBg');

    const camBgDisplay = document.getElementById('debugCamBgDisplay');

    const camBgHex = document.getElementById('debugCamBgHex');

    camBgDisplay.addEventListener('click', () => camBgInput.click());

    camBgInput.addEventListener('input', (e) => {

      updateColorDisplay(camBgInput, camBgDisplay, camBgHex);

      scene.background.setHex(parseInt(camBgInput.value.substring(1), 16));

    });

    const camFOVSlider = document.getElementById('debugCamFOV');

    const camFOVValue = document.getElementById('debugCamFOVValue');

    camFOVSlider.addEventListener('input', (e) => {

      camera.fov = parseFloat(camFOVSlider.value);

      camera.updateProjectionMatrix();

      syncSliderValue(camFOVSlider, camFOVValue);

    });

    const camXSlider = document.getElementById('debugCamX');

    const camXValue = document.getElementById('debugCamXValue');

    camXSlider.addEventListener('input', (e) => {

      camera.position.x = parseFloat(camXSlider.value);

      controls.update();

      syncSliderValue(camXSlider, camXValue);

    });

    const camYSlider = document.getElementById('debugCamY');

    const camYValue = document.getElementById('debugCamYValue');

    camYSlider.addEventListener('input', (e) => {

      camera.position.y = parseFloat(camYSlider.value);

      controls.update();

      syncSliderValue(camYSlider, camYValue);

    });

    const camZSlider = document.getElementById('debugCamZ');

    const camZValue = document.getElementById('debugCamZValue');

    camZSlider.addEventListener('input', (e) => {

      camera.position.z = parseFloat(camZSlider.value);

      controls.update();

      syncSliderValue(camZSlider, camZValue);

    });

    const camNearSlider = document.getElementById('debugCamNear');

    const camNearValue = document.getElementById('debugCamNearValue');

    camNearSlider.addEventListener('input', (e) => {

      camera.near = parseFloat(camNearSlider.value);

      camera.updateProjectionMatrix();

      syncSliderValue(camNearSlider, camNearValue);

    });

    const camFarSlider = document.getElementById('debugCamFar');

    const camFarValue = document.getElementById('debugCamFarValue');

    camFarSlider.addEventListener('input', (e) => {

      camera.far = parseFloat(camFarSlider.value);

      camera.updateProjectionMatrix();

      syncSliderValue(camFarSlider, camFarValue);

    });

    // Lighting controls
    const hemiSkyInput = document.getElementById('debugHemiSky');
    const hemiSkyDisplay = document.getElementById('debugHemiSkyDisplay');
    const hemiSkyHex = document.getElementById('debugHemiSkyHex');
    hemiSkyDisplay.addEventListener('click', () => hemiSkyInput.click());
    hemiSkyInput.addEventListener('input', (e) => {
      updateColorDisplay(hemiSkyInput, hemiSkyDisplay, hemiSkyHex);
      const color = parseInt(hemiSkyInput.value.substring(1), 16);
      hemi.color.setHex(color);
    });

    const hemiGroundInput = document.getElementById('debugHemiGround');
    const hemiGroundDisplay = document.getElementById('debugHemiGroundDisplay');
    const hemiGroundHex = document.getElementById('debugHemiGroundHex');
    hemiGroundDisplay.addEventListener('click', () => hemiGroundInput.click());
    hemiGroundInput.addEventListener('input', (e) => {
      updateColorDisplay(hemiGroundInput, hemiGroundDisplay, hemiGroundHex);
      const color = parseInt(hemiGroundInput.value.substring(1), 16);
      hemi.groundColor.setHex(color);
    });

    const hemiIntensitySlider = document.getElementById('debugHemiIntensity');
    const hemiIntensityValue = document.getElementById('debugHemiIntensityValue');
    hemiIntensitySlider.addEventListener('input', (e) => {
      const intensity = parseFloat(hemiIntensitySlider.value);
      hemi.intensity = intensity;
      syncSliderValue(hemiIntensitySlider, hemiIntensityValue);
    });

    const dirColorInput = document.getElementById('debugDirColor');
    const dirColorDisplay = document.getElementById('debugDirColorDisplay');
    const dirColorHex = document.getElementById('debugDirColorHex');
    dirColorDisplay.addEventListener('click', () => dirColorInput.click());
    dirColorInput.addEventListener('input', (e) => {
      updateColorDisplay(dirColorInput, dirColorDisplay, dirColorHex);
      const color = parseInt(dirColorInput.value.substring(1), 16);
      dir.color.setHex(color);
    });

    const dirIntensitySlider = document.getElementById('debugDirIntensity');
    const dirIntensityValue = document.getElementById('debugDirIntensityValue');
    dirIntensitySlider.addEventListener('input', (e) => {
      const intensity = parseFloat(dirIntensitySlider.value);
      dir.intensity = intensity;
      syncSliderValue(dirIntensitySlider, dirIntensityValue);
    });

    const dirXSlider = document.getElementById('debugDirX');
    const dirXValue = document.getElementById('debugDirXValue');
    dirXSlider.addEventListener('input', (e) => {
      dir.position.x = parseFloat(dirXSlider.value);
      syncSliderValue(dirXSlider, dirXValue);
    });

    const dirYSlider = document.getElementById('debugDirY');
    const dirYValue = document.getElementById('debugDirYValue');
    dirYSlider.addEventListener('input', (e) => {
      dir.position.y = parseFloat(dirYSlider.value);
      syncSliderValue(dirYSlider, dirYValue);
    });

    const dirZSlider = document.getElementById('debugDirZ');
    const dirZValue = document.getElementById('debugDirZValue');
    dirZSlider.addEventListener('input', (e) => {
      dir.position.z = parseFloat(dirZSlider.value);
      syncSliderValue(dirZSlider, dirZValue);
    });

    const dirDistanceSlider = document.getElementById('debugDirDistance');
    const dirDistanceValue = document.getElementById('debugDirDistanceValue');
    dirDistanceSlider.addEventListener('input', (e) => {
      dir.distance = parseFloat(dirDistanceSlider.value);
      syncSliderValue(dirDistanceSlider, dirDistanceValue);
    });

    const dirDecaySlider = document.getElementById('debugDirDecay');
    const dirDecayValue = document.getElementById('debugDirDecayValue');
    dirDecaySlider.addEventListener('input', (e) => {
      dir.decay = parseFloat(dirDecaySlider.value);
      syncSliderValue(dirDecaySlider, dirDecayValue);
    });

    // Center light controls
    const centerLightColorInput = document.getElementById('debugCenterLightColor');
    const centerLightColorDisplay = document.getElementById('debugCenterLightColorDisplay');
    const centerLightColorHex = document.getElementById('debugCenterLightColorHex');
    
    centerLightColorDisplay.addEventListener('click', () => centerLightColorInput.click());
    
    centerLightColorInput.addEventListener('input', (e) => {
      updateColorDisplay(centerLightColorInput, centerLightColorDisplay, centerLightColorHex);
      const color = parseInt(centerLightColorInput.value.substring(1), 16);
      centerLight.color.setHex(color);
    });

    const centerLightIntensitySlider = document.getElementById('debugCenterLightIntensity');
    const centerLightIntensityValue = document.getElementById('debugCenterLightIntensityValue');
    centerLightIntensitySlider.addEventListener('input', (e) => {
      const intensity = parseFloat(centerLightIntensitySlider.value);
      centerLight.intensity = intensity;
      syncSliderValue(centerLightIntensitySlider, centerLightIntensityValue);
    });

    const centerLightDistanceSlider = document.getElementById('debugCenterLightDistance');
    const centerLightDistanceValue = document.getElementById('debugCenterLightDistanceValue');
    centerLightDistanceSlider.addEventListener('input', (e) => {
      centerLight.distance = parseFloat(centerLightDistanceSlider.value);
      syncSliderValue(centerLightDistanceSlider, centerLightDistanceValue);
    });

    const centerLightDecaySlider = document.getElementById('debugCenterLightDecay');
    const centerLightDecayValue = document.getElementById('debugCenterLightDecayValue');
    centerLightDecaySlider.addEventListener('input', (e) => {
      centerLight.decay = parseFloat(centerLightDecaySlider.value);
      syncSliderValue(centerLightDecaySlider, centerLightDecayValue);
    });

    const dirShadowMapSizeSlider = document.getElementById('debugDirShadowMapSize');
    const dirShadowMapSizeValue = document.getElementById('debugDirShadowMapSizeValue');
    dirShadowMapSizeSlider.addEventListener('input', (e) => {
      const size = parseInt(dirShadowMapSizeSlider.value);
      dir.shadow.mapSize.width = size;
      dir.shadow.mapSize.height = size;
      dir.shadow.mapSize.needsUpdate = true;
      syncSliderValue(dirShadowMapSizeSlider, dirShadowMapSizeValue);
    });

    const dirShadowRadiusSlider = document.getElementById('debugDirShadowRadius');
    const dirShadowRadiusValue = document.getElementById('debugDirShadowRadiusValue');
    dirShadowRadiusSlider.addEventListener('input', (e) => {
      dir.shadow.radius = parseFloat(dirShadowRadiusSlider.value);
      syncSliderValue(dirShadowRadiusSlider, dirShadowRadiusValue);
    });

    document.querySelectorAll('#debugPanel input[type="range"]').forEach(slider => {

      updateSliderFill(slider);

    });


    const presets = {

      color: {

        default: { hidden: 0x1a2233, revealed: 0x001f3f, flag: 0x8b0000, mine: 0x842029 },

        dark: { hidden: 0x0a0d15, revealed: 0x000a1a, flag: 0x5a0000, mine: 0x4a1015 },

        bright: { hidden: 0x2a3344, revealed: 0x003f5f, flag: 0xcc0000, mine: 0xaa3040 },

        retro: { hidden: 0x1a1a33, revealed: 0x003333, flag: 0xff6600, mine: 0xff0066 }

      },

      light: {

        default: { hemiSky: 0x96baff, hemiGround: 0x1a1e29, hemiIntensity: 0.8, dirColor: 0xffffff, dirIntensity: 0.6, dirPos: [3,2,1] },

        bright: { hemiSky: 0xffffff, hemiGround: 0x888888, hemiIntensity: 1.2, dirColor: 0xffffff, dirIntensity: 1.0, dirPos: [3,2,1] },

        moody: { hemiSky: 0x4a5aff, hemiGround: 0x0a0a1a, hemiIntensity: 0.5, dirColor: 0xffaa88, dirIntensity: 0.4, dirPos: [2,3,1] },

        flat: { hemiSky: 0xffffff, hemiGround: 0xffffff, hemiIntensity: 1.0, dirColor: 0xffffff, dirIntensity: 0.0, dirPos: [0,0,1] }

      },

      material: {

        default: { type: 'basic' },

        flat: { type: 'basic' },

        shiny: { type: 'standard', roughness: 0.2, metalness: 0.3 }

      }

    };

    function updateDebugValues() {

      if (freqSlider) { freqSlider.value = state.f; updateSliderFill(freqSlider); freqValue.value = state.f; }

      if (mineRatioSlider) { mineRatioSlider.value = debugSettings.mineRatio; updateSliderFill(mineRatioSlider); mineRatioValue.value = debugSettings.mineRatio; }

      if (initialRevealSlider) { initialRevealSlider.value = debugSettings.initialRevealPercent; updateSliderFill(initialRevealSlider); initialRevealValue.value = debugSettings.initialRevealPercent; }

      if (emptyRatioSlider) { emptyRatioSlider.value = debugSettings.emptyTilePercent; updateSliderFill(emptyRatioSlider); emptyRatioValue.value = debugSettings.emptyTilePercent; }

      if (camXSlider) { camXSlider.value = camera.position.x.toFixed(1); updateSliderFill(camXSlider); camXValue.value = camera.position.x.toFixed(1); }

      if (camYSlider) { camYSlider.value = camera.position.y.toFixed(1); updateSliderFill(camYSlider); camYValue.value = camera.position.y.toFixed(1); }

      if (camZSlider) { camZSlider.value = camera.position.z.toFixed(1); updateSliderFill(camZSlider); camZValue.value = camera.position.z.toFixed(1); }

      if (camFOVSlider) { camFOVSlider.value = camera.fov; updateSliderFill(camFOVSlider); camFOVValue.value = camera.fov; }

    }

    document.getElementById('debugImmortal').addEventListener('change', (e) => {

      // Immortal mode - prevents game over on mine hit

    });

    // Sound controls
    const clickSoundSlider = document.getElementById('debugClickSound');
    const clickSoundValue = document.getElementById('debugClickSoundValue');
    const gameOverSoundSlider = document.getElementById('debugGameOverSound');
    const gameOverSoundValue = document.getElementById('debugGameOverSoundValue');

    if (clickSoundSlider) {
      clickSoundSlider.addEventListener('input', (e) => {
        const style = Math.round(parseFloat(e.target.value));
        setClickSoundStyle(style);
        if (clickSoundValue) {
          clickSoundValue.value = style;
        }
        // Preview the sound
        requestAnimationFrame(() => {
          playClick();
        });
      });
    }

    if (gameOverSoundSlider) {
      gameOverSoundSlider.addEventListener('input', (e) => {
        const style = Math.round(parseFloat(e.target.value));
        setGameOverSoundStyle(style);
        if (gameOverSoundValue) {
          gameOverSoundValue.value = style;
        }
        // Preview the sound
        requestAnimationFrame(() => {
          playGameOver();
        });
      });
    }

    document.getElementById('debugCamFog').addEventListener('change', (e) => {

      if (e.target.checked) {

        scene.fog = new THREE.Fog(scene.background, camera.near, camera.far);

      } else {

        scene.fog = null;

      }

    });

    setInterval(updateDebugValues, 1000);



    // Start

    function alignTimerWidth() {

      const timerSection = document.querySelector('.timer-section');

      const globeBtn = document.getElementById('globeBtn');

      const uiContainer = document.querySelector('.ui');

      if (timerSection && globeBtn && uiContainer) {

        const uiRect = uiContainer.getBoundingClientRect();

        const globeBtnRect = globeBtn.getBoundingClientRect();

        const timerLeft = uiRect.left + 16;

        const globeRightEdge = globeBtnRect.right;

        const timerWidth = globeRightEdge - timerLeft;

        timerSection.style.width = timerWidth + 'px';

        timerSection.classList.add('aligned');

      }

    }

    rebuildCore(15); runTests();

    alignTimerWidth();

    requestAnimationFrame(() => {

      alignTimerWidth();

    });

    setTimeout(() => {

      alignTimerWidth();

    }, 0);

    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); requestAnimationFrame(alignTimerWidth); });
    
    // Track camera zoom for controls update optimization
    let lastCameraZoom = camera.zoom;

    const uiElement = document.querySelector('.ui');

    if (uiElement) {

      uiElement.addEventListener('click', () => {

        scheduleCompactMode();

      });

    }

    // FPS counter
    let fps = 0;
    let lastTime = performance.now();
    let frameCount = 0;
    const fpsCounter = document.getElementById('fpsCounter');

    renderer.setAnimationLoop((time)=>{
      // Only update controls if camera zoom changed (for damping)
      // Since rotation is disabled, controls.update() is mainly for zoom damping
      if (Math.abs(camera.zoom - lastCameraZoom) > 0.001) {
        controls.update();
        lastCameraZoom = camera.zoom;
      }
      
      // Check if mouse button is held but mouse hasn't moved recently (no mousemove events)
      // If button is held but no movement detected in last 50ms, treat as released
      if (dragState.isMouseButtonDown && dragState.isRotating) {
        const timeSinceLastMove = performance.now() - dragState.lastMoveTime;
        if (timeSinceLastMove > 50) {
          // Mouse button is held but hasn't moved - treat as released
          dragState.isRotating = false;
          dragState.isMouseButtonDown = false; // Treat as released for momentum purposes
        }
      }
      
      // Apply smooth rotation with momentum
      const hasVelocity = Math.abs(rotationVelocity.x) > 0.0001 || Math.abs(rotationVelocity.y) > 0.0001;
      
      // Only rotate if actively dragging OR if there's velocity to decay (after release or stopped movement)
      // If button is held but not rotating, treat exactly like release (allow momentum)
      const shouldRotate = dragState.isRotating || (hasVelocity && (!dragState.isMouseButtonDown || !dragState.isRotating));
      
      if (shouldRotate || hasVelocity) {
        // Apply rotation based on current velocity
        if (hasVelocity && shouldRotate) {
          // Get camera's local axes in world space (only when actually rotating)
          // Note: updateMatrixWorld is expensive but necessary for correct rotation
          camera.updateMatrixWorld();
          const right = new THREE.Vector3();
          const up = new THREE.Vector3();
          camera.matrixWorld.extractBasis(right, up, new THREE.Vector3());
          
          const rotY = new THREE.Quaternion().setFromAxisAngle(up, rotationVelocity.x);
          const rotX = new THREE.Quaternion().setFromAxisAngle(right, rotationVelocity.y);
          const combinedRot = rotY.multiply(rotX);
          
          tileGroup.quaternion.premultiply(combinedRot);
          wireGroup.quaternion.premultiply(combinedRot);
        }
        
        // Apply friction to velocity when not actively dragging
        // Treat button held but not moving the same as released (normal friction, allow momentum)
        if (!dragState.isRotating) {
          rotationVelocity.x *= rotationFriction;
          rotationVelocity.y *= rotationFriction;
          
          // Stop if velocity is too small
          if (Math.abs(rotationVelocity.x) < 0.0001) rotationVelocity.x = 0;
          if (Math.abs(rotationVelocity.y) < 0.0001) rotationVelocity.y = 0;
        }
      }
      
      renderer.render(scene, camera); 
      
      // Update FPS counter
      frameCount++;
      const currentTime = performance.now();
      if (currentTime >= lastTime + 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = currentTime;
        if (fpsCounter) {
          fpsCounter.textContent = `FPS: ${fps}`;
        }
      }
    });

  </script>

</body>

</html>

